
--
-- RoboChart generator version 3.0.0.202209090727
-- Automatically generated on 19-06-2024 12:20:52
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module SAR_Handheld
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel DisplayStatus: InOut.Status
	channel GetDroneBatteryStatus: InOut
	channel FollowFlightPlan: InOut
	channel InputFlightPlan: InOut.SearchType
	channel InputAreaCoordinates: InOut.AreaCoords
	channel InputHomeCoordinate: InOut.Coord
	channel InputCoordinate: InOut.Coord
	channel ManualMovement: InOut.Direction
	channel StopSearch: InOut
	channel ReturnToHome: InOut
	channel PowerDrone: InOut
	channel PowerHandheld: InOut
	
	channel DisplayDroneBatteryStatusCall: Status
	channel powerDroneAutomaticallyCall
	channel OnOffDroneCall
	channel FollowPlanCall: SearchType
	channel FlyToCoordinateCall: Coord
	channel MoveDroneCall: Direction
	channel FlyToAreaCoordinatesCall: AreaCoords
	channel DroneStopSearchCall
	channel GetBatteryStatusCall
	channel stopHandheldOperatingCall: core_boolean.core_nat
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	channel get_systemDroneOn, set_systemDroneOn: core_boolean
	channel get_systemHandheld, set_systemHandheld: SystemPower
	channel get_FlightPlan, set_FlightPlan: SearchType
	
	-- channel set with all visible events
	sem__events = {|
		DisplayStatus,
		GetDroneBatteryStatus,
		FollowFlightPlan,
		InputFlightPlan,
		InputAreaCoordinates,
		InputHomeCoordinate,
		InputCoordinate,
		ManualMovement,
		StopSearch,
		ReturnToHome,
		PowerDrone,
		PowerHandheld
	,	DisplayDroneBatteryStatusCall,
		powerDroneAutomaticallyCall,
		OnOffDroneCall,
		FollowPlanCall,
		FlyToCoordinateCall,
		MoveDroneCall,
		FlyToAreaCoordinatesCall,
		DroneStopSearchCall,
		GetBatteryStatusCall,
		stopHandheldOperatingCall
	|}
	
	-- declaring controller
		module ctrl_ref0
			shared_variable_events = {|
				set_EXT_systemDroneOn,
				set_EXT_systemHandheld,
				set_EXT_FlightPlan
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel FollowFlightPlan: InOut
			channel InputFlightPlan: InOut.SearchType
			channel InputAreaCoordinates: InOut.AreaCoords
			channel InputHomeCoordinate: InOut.Coord
			channel InputCoordinate: InOut.Coord
			channel ManualMovement: InOut.Direction
			channel StopSearch: InOut
			channel ReturnToHome: InOut
			
			channel set_systemDroneOn: core_boolean
			channel get_systemDroneOn: core_boolean
			channel set_systemHandheld: SystemPower
			channel get_systemHandheld: SystemPower
			channel set_FlightPlan: SearchType
			channel get_FlightPlan: SearchType
			
			channel set_EXT_systemDroneOn: core_boolean
			channel set_EXT_systemHandheld: SystemPower
			channel set_EXT_FlightPlan: SearchType
			
			-- declaring call and ret events for undefined operations
			channel OnOffDroneCall
			channel MoveDroneCall: Direction
			channel DroneStopSearchCall
			channel FlyToCoordinateCall: Coord
			channel FlyToAreaCoordinatesCall: AreaCoords
			channel FollowPlanCall: SearchType
			channel stopHandheldOperatingCall: core_boolean.core_nat
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	FollowFlightPlan,
				InputFlightPlan,
				InputAreaCoordinates,
				InputHomeCoordinate,
				InputCoordinate,
				ManualMovement,
				StopSearch,
				ReturnToHome
			,	set_EXT_systemDroneOn, set_systemDroneOn,
				set_EXT_systemHandheld, set_systemHandheld,
				set_EXT_FlightPlan, set_FlightPlan
			,	OnOffDroneCall,
				MoveDroneCall,
				DroneStopSearchCall,
				FlyToCoordinateCall,
				FlyToAreaCoordinatesCall,
				FollowPlanCall,
				stopHandheldOperatingCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {|get_systemDroneOn,set_systemDroneOn,get_systemHandheld,set_systemHandheld,get_FlightPlan,set_FlightPlan|}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_f0|
				              NID_WaitForInput|
				              NID_ExecuteFlightPlan|
				              NID_s0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_aFlightPlan, set_aFlightPlan, setL_aFlightPlan, setR_aFlightPlan: SearchType
				channel get_aAreaSearchPoints, set_aAreaSearchPoints, setL_aAreaSearchPoints, setR_aAreaSearchPoints: AreaCoords
				channel get_aHomeCoord, set_aHomeCoord, setL_aHomeCoord, setR_aHomeCoord: Coord
				channel get_aWayPoint, set_aWayPoint, setL_aWayPoint, setR_aWayPoint: Coord
				channel get_adirection, set_adirection, setL_adirection, setR_adirection: Direction
				channel get_flightPlanFinished, set_flightPlanFinished, setL_flightPlanFinished, setR_flightPlanFinished: core_boolean
				channel get_systemDroneOn, set_systemDroneOn, setL_systemDroneOn, setR_systemDroneOn: core_boolean
				channel get_systemHandheld, set_systemHandheld, setL_systemHandheld, setR_systemHandheld: SystemPower
				channel get_FlightPlan, set_FlightPlan, setL_FlightPlan, setR_FlightPlan: SearchType
				
				-- Shared variable channels
				channel set_EXT_systemDroneOn: core_boolean
				channel set_EXT_systemHandheld: SystemPower
				channel set_EXT_FlightPlan: SearchType
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel FollowFlightPlan__: NIDS.InOut
				channel FollowFlightPlan: InOut
				channel InputFlightPlan__: NIDS.InOut.SearchType
				channel InputFlightPlan: InOut.SearchType
				channel InputAreaCoordinates__: NIDS.InOut.AreaCoords
				channel InputAreaCoordinates: InOut.AreaCoords
				channel InputHomeCoordinate__: NIDS.InOut.Coord
				channel InputHomeCoordinate: InOut.Coord
				channel InputCoordinate__: NIDS.InOut.Coord
				channel InputCoordinate: InOut.Coord
				channel ManualMovement__: NIDS.InOut.Direction
				channel ManualMovement: InOut.Direction
				channel StopSearch__: NIDS.InOut
				channel StopSearch: InOut
				channel ReturnToHome__: NIDS.InOut
				channel ReturnToHome: InOut
				
				-- Declaring call and ret events for undefined operations
				channel MoveDroneCall: Direction
				channel DroneStopSearchCall
				channel FlyToCoordinateCall: Coord
				channel FlyToAreaCoordinatesCall: AreaCoords
				channel FollowPlanCall: SearchType
				
				enterSS = {|
				i0::enter,
				f0::enter,
				WaitForInput::enter,
				ExecuteFlightPlan::enter,
				s0::enter
				|}
				
				enteredSS = 	{|
				f0::entered,
				WaitForInput::entered,
				ExecuteFlightPlan::entered,
				s0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_systemDroneOn,
					set_EXT_systemHandheld,
					set_EXT_FlightPlan
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_systemDroneOn, set_systemDroneOn,
					set_EXT_systemHandheld, set_systemHandheld,
					set_EXT_FlightPlan, set_FlightPlan
				,	FollowFlightPlan,
					InputFlightPlan,
					InputAreaCoordinates,
					InputHomeCoordinate,
					InputCoordinate,
					ManualMovement,
					StopSearch,
					ReturnToHome
				,	MoveDroneCall,
					DroneStopSearchCall,
					FlyToCoordinateCall,
					FlyToAreaCoordinatesCall,
					FollowPlanCall
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_f0 : core_clock_type 
				channel get_CLID_WaitForInput : core_clock_type 
				channel get_CLID_s0 : core_clock_type 
				channel get_CLID_ExecuteFlightPlan : core_clock_type 
				--channel increment__
				
				CLID_f0_clock_type(id__,
						          const_PilotDisplayStm_hToDCommTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForInput_clock_type(id__,
						          const_PilotDisplayStm_hToDCommTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_s0_clock_type(id__,
						          const_PilotDisplayStm_hToDCommTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_ExecuteFlightPlan_clock_type(id__,
						          const_PilotDisplayStm_hToDCommTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_PilotDisplayStm_hToDCommTime) = D__(id__,
									    const_PilotDisplayStm_hToDCommTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PilotDisplayStm_hToDCommTime) = D__(id__,
									    const_PilotDisplayStm_hToDCommTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForInput
					module WaitForInput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PilotDisplayStm_hToDCommTime) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: ExecuteFlightPlan
					module ExecuteFlightPlan
					
					enterSS = 
							{|			i0::enter,
								WaitForInput::enter,
								f0::enter,
								s0::enter
							|}
					enteredSS = 
							{|			WaitForInput::entered,
								f0::entered,
								s0::entered
							|}
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						-- declaring identifiers of transitions
						datatype NIDS = 
						              NID_i0|
						              NID_WaitForInput|
						              NID_f0|
						              NID_s0
						
						channel internal__ : NIDS
						channel FollowFlightPlan__: NIDS.InOut
						channel InputFlightPlan__: NIDS.InOut.SearchType
						channel InputAreaCoordinates__: NIDS.InOut.AreaCoords
						channel InputHomeCoordinate__: NIDS.InOut.Coord
						channel InputCoordinate__: NIDS.InOut.Coord
						channel ManualMovement__: NIDS.InOut.Direction
						channel StopSearch__: NIDS.InOut
						channel ReturnToHome__: NIDS.InOut
						
						channel get_CLID_s0 : core_clock_type 
						channel get_CLID_WaitForInput : core_clock_type 
						channel get_CLID_f0 : core_clock_type 
						--channel increment__
						
						CLID_s0_clock_type(id__,
								          const_PilotDisplayStm_hToDCommTime) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						CLID_WaitForInput_clock_type(id__,
								          const_PilotDisplayStm_hToDCommTime) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						CLID_f0_clock_type(id__,
								          const_PilotDisplayStm_hToDCommTime) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						
						--	Nodes
						-- declaring all nodes
						
						----------------------------------------------------------------------
						-- Initial: i0
						module i0
						exports
						
							channel enter, interrupt
							
							Timed(OneStep) {
								D__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
										
										Termination = terminate -> SKIP
										
										Active 		= share__choice(interrupt -> SKIP) ; Inactive
									within
										Inactive [| {terminate} |> SKIP)
								
								VS_O__(id__,
										    const_PilotDisplayStm_hToDCommTime) = D__(id__,
										    const_PilotDisplayStm_hToDCommTime)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: WaitForInput
						module WaitForInput
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_PilotDisplayStm_hToDCommTime) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: f0
						module f0
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(true & (share__choice(set_flightPlanFinished!true -> SKIP))) ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(true & (share__choice(set_flightPlanFinished!true -> SKIP))) ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_PilotDisplayStm_hToDCommTime) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: s0
						module s0
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_PilotDisplayStm_hToDCommTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_PilotDisplayStm_hToDCommTime) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_flightPlanFinished!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		dbisim(
									 			sbisim(
									 				dbisim(
									 					sbisim(
									 						(let
									 							-- IMPLEMENTATION NOTE:
									 							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 							-- modules for defining the semantics of each node.
									 							enterSS = {|
									 							i0::enter,
									 							WaitForInput::enter,
									 							f0::enter,
									 							s0::enter
									 							|}
									 							hideSet = union(enterSS,{|exit,exited,internal__|})
									 						within 
									 							((let
									 								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 								-- because CSPM modules are used for the semantics of Node.
									 								flowevts = union(enterSS,{|exit,exited,interrupt|})
									 								transSync = {|internal__.NID_s0,InputAreaCoordinates__.NID_WaitForInput.in,InputCoordinate__.NID_WaitForInput.in,StopSearch__.NID_WaitForInput.in,internal__.NID_WaitForInput,internal__.NID_i0|}
									 							within
									 								((
									 								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 								   i0::D__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   [| { share__, terminate } |] (
									 								   WaitForInput::D__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   [| { share__, terminate } |] (
									 								   f0::D__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   [| { share__, terminate } |] (
									 								   s0::D__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   )
									 								   )
									 								   )
									 								 )
									 								 [[WaitForInput::interrupt <- x__ | x__ <- {|interrupt,InputAreaCoordinates__.NID_WaitForInput.in,InputCoordinate__.NID_WaitForInput.in,StopSearch__.NID_WaitForInput.in,internal__.NID_WaitForInput|}]]
									 								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 								 [[s0::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_s0|}]]
									 								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 								 )
									 								  [[ share__ <- x__ | x__ <- {| share__,setR_aAreaSearchPoints,setR_aWayPoint |} ]] 
									 								  [[set_systemDroneOn <- setL_systemDroneOn,set_systemHandheld <- setL_systemHandheld,set_aFlightPlan <- setL_aFlightPlan]]
									 								 )
									 								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 								 			,setL_systemDroneOn
									 								 			,setL_systemHandheld
									 								 			,setL_aFlightPlan
									 								 			,setR_aAreaSearchPoints
									 								 			 			,setR_aWayPoint
									 								 			|}) |]
									 								 ((i0::enter -> Transitions(id__,
									 								 		    const_PilotDisplayStm_hToDCommTime))
									 								  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_systemHandheld,setL_aFlightPlan |} ]]
									 								  [[set_aAreaSearchPoints <- setR_aAreaSearchPoints,set_aWayPoint <- setR_aWayPoint]]
									 								 )
									 								)[[setL_systemDroneOn <- set_systemDroneOn,setL_systemHandheld <- set_systemHandheld,setL_aFlightPlan <- set_aFlightPlan]]
									 								 [[setR_aAreaSearchPoints <- set_aAreaSearchPoints,setR_aWayPoint <- set_aWayPoint]]
									 								)
									 							)
									 							 \ hideSet)
									 							[[
									 								FollowFlightPlan__.x____ <- FollowFlightPlan,
									 								InputFlightPlan__.x____ <- InputFlightPlan,
									 								InputAreaCoordinates__.x____ <- InputAreaCoordinates,
									 								InputHomeCoordinate__.x____ <- InputHomeCoordinate,
									 								InputCoordinate__.x____ <- InputCoordinate,
									 								ManualMovement__.x____ <- ManualMovement,
									 								StopSearch__.x____ <- StopSearch,
									 								ReturnToHome__.x____ <- ReturnToHome
									 								| x____ <- NIDS
									 							]]
									 						)
									 						[| {|get_CLID_f0,f0::entered,terminate|} |]
									 						dbisim(Clock_CLID_f0(id__,0,
									 								          const_PilotDisplayStm_hToDCommTime))
									 					)\{|get_CLID_f0|}
									 				)
									 				[| {|get_CLID_WaitForInput,WaitForInput::entered,terminate|} |]
									 				dbisim(Clock_CLID_WaitForInput(id__,0,
									 						          const_PilotDisplayStm_hToDCommTime))
									 			)\{|get_CLID_WaitForInput|}
									 		)
									 		[| {|get_CLID_s0,s0::entered,terminate|} |]
									 		dbisim(Clock_CLID_s0(id__,0,
									 				          const_PilotDisplayStm_hToDCommTime))
									 	)\{|get_CLID_s0|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_adirection,setR_systemDroneOn,setR_aAreaSearchPoints,setR_aHomeCoord,setR_flightPlanFinished,setR_FlightPlan,setR_aWayPoint,setR_aFlightPlan,setR_systemHandheld |} ]] 
									  [[set_adirection <- setL_adirection,set_systemDroneOn <- setL_systemDroneOn,set_aAreaSearchPoints <- setL_aAreaSearchPoints,set_aHomeCoord <- setL_aHomeCoord,set_flightPlanFinished <- setL_flightPlanFinished,set_FlightPlan <- setL_FlightPlan,set_aWayPoint <- setL_aWayPoint,set_aFlightPlan <- setL_aFlightPlan,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_adirection
									 			,setL_systemDroneOn
									 			,setL_aAreaSearchPoints
									 			,setL_aHomeCoord
									 			,setL_flightPlanFinished
									 			,setL_FlightPlan
									 			,setL_aWayPoint
									 			,setL_aFlightPlan
									 			,setL_systemHandheld
									 			,setR_adirection
									 			 			,setR_systemDroneOn
									 			 			,setR_aAreaSearchPoints
									 			 			,setR_aHomeCoord
									 			 			,setR_flightPlanFinished
									 			 			,setR_FlightPlan
									 			 			,setR_aWayPoint
									 			 			,setR_aFlightPlan
									 			 			,setR_systemHandheld
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_adirection,setL_systemDroneOn,setL_aAreaSearchPoints,setL_aHomeCoord,setL_flightPlanFinished,setL_FlightPlan,setL_aWayPoint,setL_aFlightPlan,setL_systemHandheld |} ]]
									  [[set_adirection <- setR_adirection,set_systemDroneOn <- setR_systemDroneOn,set_aAreaSearchPoints <- setR_aAreaSearchPoints,set_aHomeCoord <- setR_aHomeCoord,set_flightPlanFinished <- setR_flightPlanFinished,set_FlightPlan <- setR_FlightPlan,set_aWayPoint <- setR_aWayPoint,set_aFlightPlan <- setR_aFlightPlan,set_systemHandheld <- setR_systemHandheld]]
									 )
									)[[setL_adirection <- set_adirection,setL_systemDroneOn <- set_systemDroneOn,setL_aAreaSearchPoints <- set_aAreaSearchPoints,setL_aHomeCoord <- set_aHomeCoord,setL_flightPlanFinished <- set_flightPlanFinished,setL_FlightPlan <- set_FlightPlan,setL_aWayPoint <- set_aWayPoint,setL_aFlightPlan <- set_aFlightPlan,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_adirection <- set_adirection,setR_systemDroneOn <- set_systemDroneOn,setR_aAreaSearchPoints <- set_aAreaSearchPoints,setR_aHomeCoord <- set_aHomeCoord,setR_flightPlanFinished <- set_flightPlanFinished,setR_FlightPlan <- set_FlightPlan,setR_aWayPoint <- set_aWayPoint,setR_aFlightPlan <- set_aFlightPlan,setR_systemHandheld <- set_systemHandheld]]
									)\union(enteredSS,{terminate}) 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_flightPlanFinished!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		dbisim(
									 			sbisim(
									 				dbisim(
									 					sbisim(
									 						(let
									 							-- IMPLEMENTATION NOTE:
									 							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 							-- modules for defining the semantics of each node.
									 							enterSS = {|
									 							i0::enter,
									 							WaitForInput::enter,
									 							f0::enter,
									 							s0::enter
									 							|}
									 							hideSet = union(enterSS,{|exit,exited,internal__|})
									 						within 
									 							((let
									 								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 								-- because CSPM modules are used for the semantics of Node.
									 								flowevts = union(enterSS,{|exit,exited,interrupt|})
									 								transSync = {|internal__.NID_s0,InputAreaCoordinates__.NID_WaitForInput.in,InputCoordinate__.NID_WaitForInput.in,StopSearch__.NID_WaitForInput.in,internal__.NID_WaitForInput,internal__.NID_i0|}
									 							within
									 								((
									 								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 								   i0::VS_O__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   [| { share__, terminate } |] (
									 								   WaitForInput::VS_O__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   [| { share__, terminate } |] (
									 								   f0::VS_O__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   [| { share__, terminate } |] (
									 								   s0::VS_O__(id__,
									 								   		    const_PilotDisplayStm_hToDCommTime)
									 								   )
									 								   )
									 								   )
									 								 )
									 								 [[WaitForInput::interrupt <- x__ | x__ <- {|interrupt,InputAreaCoordinates__.NID_WaitForInput.in,InputCoordinate__.NID_WaitForInput.in,StopSearch__.NID_WaitForInput.in,internal__.NID_WaitForInput|}]]
									 								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 								 [[s0::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_s0|}]]
									 								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 								 )
									 								  [[ share__ <- x__ | x__ <- {| share__,setR_aAreaSearchPoints,setR_aWayPoint |} ]] 
									 								  [[set_systemDroneOn <- setL_systemDroneOn,set_systemHandheld <- setL_systemHandheld,set_aFlightPlan <- setL_aFlightPlan]]
									 								 )
									 								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 								 			,setL_systemDroneOn
									 								 			,setL_systemHandheld
									 								 			,setL_aFlightPlan
									 								 			,setR_aAreaSearchPoints
									 								 			 			,setR_aWayPoint
									 								 			|}) |]
									 								 ((i0::enter -> Transitions(id__,
									 								 		    const_PilotDisplayStm_hToDCommTime))
									 								  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_systemHandheld,setL_aFlightPlan |} ]]
									 								  [[set_aAreaSearchPoints <- setR_aAreaSearchPoints,set_aWayPoint <- setR_aWayPoint]]
									 								 )
									 								)[[setL_systemDroneOn <- set_systemDroneOn,setL_systemHandheld <- set_systemHandheld,setL_aFlightPlan <- set_aFlightPlan]]
									 								 [[setR_aAreaSearchPoints <- set_aAreaSearchPoints,setR_aWayPoint <- set_aWayPoint]]
									 								)
									 							)
									 							 \ hideSet)
									 							[[
									 								FollowFlightPlan__.x____ <- FollowFlightPlan,
									 								InputFlightPlan__.x____ <- InputFlightPlan,
									 								InputAreaCoordinates__.x____ <- InputAreaCoordinates,
									 								InputHomeCoordinate__.x____ <- InputHomeCoordinate,
									 								InputCoordinate__.x____ <- InputCoordinate,
									 								ManualMovement__.x____ <- ManualMovement,
									 								StopSearch__.x____ <- StopSearch,
									 								ReturnToHome__.x____ <- ReturnToHome
									 								| x____ <- NIDS
									 							]]
									 						)
									 						[| {|get_CLID_f0,f0::entered,terminate|} |]
									 						dbisim(Clock_CLID_f0(id__,0,
									 								          const_PilotDisplayStm_hToDCommTime))
									 					)\{|get_CLID_f0|}
									 				)
									 				[| {|get_CLID_WaitForInput,WaitForInput::entered,terminate|} |]
									 				dbisim(Clock_CLID_WaitForInput(id__,0,
									 						          const_PilotDisplayStm_hToDCommTime))
									 			)\{|get_CLID_WaitForInput|}
									 		)
									 		[| {|get_CLID_s0,s0::entered,terminate|} |]
									 		dbisim(Clock_CLID_s0(id__,0,
									 				          const_PilotDisplayStm_hToDCommTime))
									 	)\{|get_CLID_s0|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_adirection,setR_systemDroneOn,setR_aAreaSearchPoints,setR_aHomeCoord,setR_flightPlanFinished,setR_FlightPlan,setR_aWayPoint,setR_aFlightPlan,setR_systemHandheld |} ]] 
									  [[set_adirection <- setL_adirection,set_systemDroneOn <- setL_systemDroneOn,set_aAreaSearchPoints <- setL_aAreaSearchPoints,set_aHomeCoord <- setL_aHomeCoord,set_flightPlanFinished <- setL_flightPlanFinished,set_FlightPlan <- setL_FlightPlan,set_aWayPoint <- setL_aWayPoint,set_aFlightPlan <- setL_aFlightPlan,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_adirection
									 			,setL_systemDroneOn
									 			,setL_aAreaSearchPoints
									 			,setL_aHomeCoord
									 			,setL_flightPlanFinished
									 			,setL_FlightPlan
									 			,setL_aWayPoint
									 			,setL_aFlightPlan
									 			,setL_systemHandheld
									 			,setR_adirection
									 			 			,setR_systemDroneOn
									 			 			,setR_aAreaSearchPoints
									 			 			,setR_aHomeCoord
									 			 			,setR_flightPlanFinished
									 			 			,setR_FlightPlan
									 			 			,setR_aWayPoint
									 			 			,setR_aFlightPlan
									 			 			,setR_systemHandheld
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_adirection,setL_systemDroneOn,setL_aAreaSearchPoints,setL_aHomeCoord,setL_flightPlanFinished,setL_FlightPlan,setL_aWayPoint,setL_aFlightPlan,setL_systemHandheld |} ]]
									  [[set_adirection <- setR_adirection,set_systemDroneOn <- setR_systemDroneOn,set_aAreaSearchPoints <- setR_aAreaSearchPoints,set_aHomeCoord <- setR_aHomeCoord,set_flightPlanFinished <- setR_flightPlanFinished,set_FlightPlan <- setR_FlightPlan,set_aWayPoint <- setR_aWayPoint,set_aFlightPlan <- setR_aFlightPlan,set_systemHandheld <- setR_systemHandheld]]
									 )
									)[[setL_adirection <- set_adirection,setL_systemDroneOn <- set_systemDroneOn,setL_aAreaSearchPoints <- set_aAreaSearchPoints,setL_aHomeCoord <- set_aHomeCoord,setL_flightPlanFinished <- set_flightPlanFinished,setL_FlightPlan <- set_FlightPlan,setL_aWayPoint <- set_aWayPoint,setL_aFlightPlan <- set_aFlightPlan,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_adirection <- set_adirection,setR_systemDroneOn <- set_systemDroneOn,setR_aAreaSearchPoints <- set_aAreaSearchPoints,setR_aHomeCoord <- set_aHomeCoord,setR_flightPlanFinished <- set_flightPlanFinished,setR_FlightPlan <- set_FlightPlan,setR_aWayPoint <- set_aWayPoint,setR_aFlightPlan <- set_aFlightPlan,setR_systemHandheld <- set_systemHandheld]]
									)\{terminate} 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
							
							Transitions(id__,
									    const_PilotDisplayStm_hToDCommTime) = ((let
								Trans = share__choice(get_systemDroneOn?systemDroneOn -> get_systemHandheld?systemHandheld -> get_aFlightPlan?aFlightPlan -> TimeOut_1(
									 (share__ -> SKIP
									 [] dbisim(((systemDroneOn and (systemHandheld==SystemPower_On)))&(internal__!NID_s0 -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
									 [] dbisim((InputAreaCoordinates__!NID_WaitForInput.in?aAreaSearchPoints:{aAreaSearchPoints|aAreaSearchPoints <- AreaCoords, (aFlightPlan==SearchType_AreaSearch)} -> share__choice(set_aAreaSearchPoints!aAreaSearchPoints -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_aAreaSearchPoints?aAreaSearchPoints -> true&CALL__FlyToAreaCoordinates(
									 			id__,
									 		    const_PilotDisplayStm_hToDCommTime,
									 			aAreaSearchPoints
									 		)) ; WaitForInput::enter -> SKIP)))
									 [] dbisim((InputCoordinate__!NID_WaitForInput.in?aWayPoint:{aWayPoint|aWayPoint <- Coord, (not ((aFlightPlan==SearchType_AreaSearch)))} -> share__choice(set_aWayPoint!aWayPoint -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_aWayPoint?aWayPoint -> true&CALL__FlyToCoordinate(
									 			id__,
									 		    const_PilotDisplayStm_hToDCommTime,
									 			aWayPoint
									 		));SHARE_WAIT(const_PilotDisplayStm_hToDCommTime) ; WaitForInput::enter -> SKIP)))
									 [] dbisim((true)&(StopSearch__!NID_WaitForInput.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__DroneStopSearch(
									 			id__,
									 		    const_PilotDisplayStm_hToDCommTime
									 		);SHARE_WAIT(const_PilotDisplayStm_hToDCommTime) ; f0::enter -> SKIP)))
									 [] dbisim((((not (systemDroneOn)) or (systemHandheld==SystemPower_Off)))&(internal__!NID_WaitForInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
									 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; s0::enter -> SKIP))))
									 []
									 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
									 []
									 terminate -> SKIP
									 )
								,SKIP);Trans
								)
							within
								Trans [|{terminate}|> SKIP
							)
							)
							
							
							-- Clocks
							Clock_CLID_s0(id__,x__,
									          const_PilotDisplayStm_hToDCommTime) = 
								TimeOut_1(
									s0::entered -> Clock_CLID_s0(id__,0,
											          const_PilotDisplayStm_hToDCommTime)
									[]
									get_CLID_s0!x__ -> Clock_CLID_s0(id__,x__,
											          const_PilotDisplayStm_hToDCommTime)
									[]
									terminate -> SKIP,Clock_CLID_s0(id__,clock_type_plus(x__,1,CLID_s0_clock_type(id__,
											          const_PilotDisplayStm_hToDCommTime)),
											          const_PilotDisplayStm_hToDCommTime))
							Clock_CLID_WaitForInput(id__,x__,
									          const_PilotDisplayStm_hToDCommTime) = 
								TimeOut_1(
									WaitForInput::entered -> Clock_CLID_WaitForInput(id__,0,
											          const_PilotDisplayStm_hToDCommTime)
									[]
									get_CLID_WaitForInput!x__ -> Clock_CLID_WaitForInput(id__,x__,
											          const_PilotDisplayStm_hToDCommTime)
									[]
									terminate -> SKIP,Clock_CLID_WaitForInput(id__,clock_type_plus(x__,1,CLID_WaitForInput_clock_type(id__,
											          const_PilotDisplayStm_hToDCommTime)),
											          const_PilotDisplayStm_hToDCommTime))
							Clock_CLID_f0(id__,x__,
									          const_PilotDisplayStm_hToDCommTime) = 
								TimeOut_1(
									f0::entered -> Clock_CLID_f0(id__,0,
											          const_PilotDisplayStm_hToDCommTime)
									[]
									get_CLID_f0!x__ -> Clock_CLID_f0(id__,x__,
											          const_PilotDisplayStm_hToDCommTime)
									[]
									terminate -> SKIP,Clock_CLID_f0(id__,clock_type_plus(x__,1,CLID_f0_clock_type(id__,
											          const_PilotDisplayStm_hToDCommTime)),
											          const_PilotDisplayStm_hToDCommTime))
							
							StateClocks(id__,
									          const_PilotDisplayStm_hToDCommTime) = dbisim(Clock_CLID_s0(id__,0,
									          const_PilotDisplayStm_hToDCommTime))
							[| { terminate } |] (
							dbisim(Clock_CLID_WaitForInput(id__,0,
									          const_PilotDisplayStm_hToDCommTime))
							[| { terminate } |] (
							dbisim(Clock_CLID_f0(id__,0,
									          const_PilotDisplayStm_hToDCommTime))
							)
							)
							
							stateClockSync = {|get_CLID_s0,s0::entered,get_CLID_WaitForInput,WaitForInput::entered,get_CLID_f0,f0::entered|}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s0
					module s0
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP)));share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PilotDisplayStm_hToDCommTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP)));share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PilotDisplayStm_hToDCommTime) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__MoveDrone(id__,
							    const_PilotDisplayStm_hToDCommTime,
								param_direction) = EDeadline(MoveDroneCall.param_direction,0)
					CALL__DroneStopSearch(id__,
							    const_PilotDisplayStm_hToDCommTime) = EDeadline(DroneStopSearchCall,0)
					CALL__FlyToCoordinate(id__,
							    const_PilotDisplayStm_hToDCommTime,
								param_coord) = EDeadline(FlyToCoordinateCall.param_coord,0)
					CALL__FlyToAreaCoordinates(id__,
							    const_PilotDisplayStm_hToDCommTime,
								param_coords) = EDeadline(FlyToAreaCoordinatesCall.param_coords,0)
					CALL__FollowPlan(id__,
							    const_PilotDisplayStm_hToDCommTime,
								param_searchType) = EDeadline(FollowPlanCall.param_searchType,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_PilotDisplayStm_hToDCommTime) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_PilotDisplayStm_hToDCommTime) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {|set_EXT_systemDroneOn,set_EXT_systemHandheld,set_EXT_FlightPlan|} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PilotDisplayStm_hToDCommTime))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_PilotDisplayStm_hToDCommTime) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {|set_EXT_systemDroneOn,set_EXT_systemHandheld,set_EXT_FlightPlan|} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PilotDisplayStm_hToDCommTime))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_PilotDisplayStm_hToDCommTime) = ((let
						Trans = share__choice(get_systemDroneOn?systemDroneOn -> get_flightPlanFinished?flightPlanFinished -> get_systemHandheld?systemHandheld -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim(((systemHandheld==SystemPower_On))&(internal__!NID_s0 -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
							 [] dbisim((InputFlightPlan__!NID_WaitForInput.in?aFlightPlan:{aFlightPlan|aFlightPlan <- SearchType, systemDroneOn} -> share__choice(set_aFlightPlan!aFlightPlan -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_aFlightPlan?aFlightPlan -> true & (share__choice(set_FlightPlan!aFlightPlan -> SKIP)))) ; WaitForInput::enter -> SKIP)))
							 [] dbisim((InputHomeCoordinate__!NID_WaitForInput.in?aHomeCoord:{aHomeCoord|aHomeCoord <- Coord, systemDroneOn} -> share__choice(set_aHomeCoord!aHomeCoord -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
							 [] dbisim((systemDroneOn)&(ReturnToHome__!NID_WaitForInput.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_aHomeCoord?aHomeCoord -> true&CALL__FlyToCoordinate(
							 			id__,
							 		    const_PilotDisplayStm_hToDCommTime,
							 			aHomeCoord
							 		));SHARE_WAIT(const_PilotDisplayStm_hToDCommTime) ; WaitForInput::enter -> SKIP)))
							 [] dbisim((systemDroneOn)&(FollowFlightPlan__!NID_WaitForInput.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_aFlightPlan?aFlightPlan -> true&CALL__FollowPlan(
							 			id__,
							 		    const_PilotDisplayStm_hToDCommTime,
							 			aFlightPlan
							 		)) ; ExecuteFlightPlan::enter -> SKIP)))
							 [] dbisim((ManualMovement__!NID_WaitForInput.in?adirection:{adirection|adirection <- Direction, systemDroneOn} -> share__choice(set_adirection!adirection -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_adirection?adirection -> true&CALL__MoveDrone(
							 			id__,
							 		    const_PilotDisplayStm_hToDCommTime,
							 			adirection
							 		));SHARE_WAIT(const_PilotDisplayStm_hToDCommTime) ; WaitForInput::enter -> SKIP)))
							 [] dbisim(((systemDroneOn and flightPlanFinished))&(internal__!NID_ExecuteFlightPlan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
							 [] dbisim(((systemHandheld==SystemPower_Off))&(internal__!NID_ExecuteFlightPlan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
							 [] dbisim(((systemHandheld==SystemPower_Off))&(internal__!NID_WaitForInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
							 [] dbisim(((not (systemDroneOn)))&(internal__!NID_ExecuteFlightPlan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; s0::enter -> SKIP))))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								WaitForInput::enter,
								ExecuteFlightPlan::enter,
								s0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_s0,InputFlightPlan__.NID_WaitForInput.in,InputHomeCoordinate__.NID_WaitForInput.in,ReturnToHome__.NID_WaitForInput.in,FollowFlightPlan__.NID_WaitForInput.in,ManualMovement__.NID_WaitForInput.in,internal__.NID_ExecuteFlightPlan,internal__.NID_ExecuteFlightPlan,internal__.NID_WaitForInput,internal__.NID_ExecuteFlightPlan,internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   WaitForInput::D__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   ExecuteFlightPlan::D__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   s0::D__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   )
									   )
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[WaitForInput::interrupt <- x__ | x__ <- {|interrupt,InputFlightPlan__.NID_WaitForInput.in,InputHomeCoordinate__.NID_WaitForInput.in,ReturnToHome__.NID_WaitForInput.in,FollowFlightPlan__.NID_WaitForInput.in,ManualMovement__.NID_WaitForInput.in,internal__.NID_WaitForInput|}]]
									 [[ExecuteFlightPlan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_ExecuteFlightPlan,internal__.NID_ExecuteFlightPlan,internal__.NID_ExecuteFlightPlan|}]]
									 [[s0::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_s0|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_adirection,setR_aHomeCoord,setR_aFlightPlan |} ]] 
									  [[set_systemDroneOn <- setL_systemDroneOn,set_flightPlanFinished <- setL_flightPlanFinished,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_systemDroneOn
									 			,setL_flightPlanFinished
									 			,setL_systemHandheld
									 			,setR_adirection
									 			 			,setR_aHomeCoord
									 			 			,setR_aFlightPlan
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PilotDisplayStm_hToDCommTime))
									  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_flightPlanFinished,setL_systemHandheld |} ]]
									  [[set_adirection <- setR_adirection,set_aHomeCoord <- setR_aHomeCoord,set_aFlightPlan <- setR_aFlightPlan]]
									 )
									)[[setL_systemDroneOn <- set_systemDroneOn,setL_flightPlanFinished <- set_flightPlanFinished,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_adirection <- set_adirection,setR_aHomeCoord <- set_aHomeCoord,setR_aFlightPlan <- set_aFlightPlan]]
									)
								)
								 \ hideSet)
								[[
									FollowFlightPlan__.x____ <- FollowFlightPlan,
									InputFlightPlan__.x____ <- InputFlightPlan,
									InputAreaCoordinates__.x____ <- InputAreaCoordinates,
									InputHomeCoordinate__.x____ <- InputHomeCoordinate,
									InputCoordinate__.x____ <- InputCoordinate,
									ManualMovement__.x____ <- ManualMovement,
									StopSearch__.x____ <- StopSearch,
									ReturnToHome__.x____ <- ReturnToHome
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PilotDisplayStm_hToDCommTime)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered,get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered|}
						 within
							(MachineBody(id__,
									    const_PilotDisplayStm_hToDCommTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PilotDisplayStm_hToDCommTime)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered,get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody(id__,
															    const_PilotDisplayStm_hToDCommTime)
													[| {|get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered,terminate|} |]
													dbisim(Clock_CLID_ExecuteFlightPlan(id__,0,
															          const_PilotDisplayStm_hToDCommTime))
												)\{|get_CLID_ExecuteFlightPlan|}
											)
											[| {|get_CLID_s0,s0::entered,terminate|} |]
											dbisim(Clock_CLID_s0(id__,0,
													          const_PilotDisplayStm_hToDCommTime))
										)\{|get_CLID_s0|}
									)
									[| {|get_CLID_WaitForInput,WaitForInput::entered,terminate|} |]
									dbisim(Clock_CLID_WaitForInput(id__,0,
											          const_PilotDisplayStm_hToDCommTime))
								)\{|get_CLID_WaitForInput|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						((let
							getsetLocalChannels = {|get_aFlightPlan,set_aFlightPlan,
							get_aAreaSearchPoints,set_aAreaSearchPoints,
							get_aHomeCoord,set_aHomeCoord,
							get_aWayPoint,set_aWayPoint,
							get_adirection,set_adirection,
							get_flightPlanFinished,set_flightPlanFinished|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_PilotDisplayStm_hToDCommTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PilotDisplayStm_hToDCommTime) [| {terminate} |] Clocks(id__,
							 		          const_PilotDisplayStm_hToDCommTime))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_PilotDisplayStm_hToDCommTime) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		IteratedBehaviour(id__,
																				    const_PilotDisplayStm_hToDCommTime)
																		[| {|get_flightPlanFinished,set_flightPlanFinished,terminate|} |]
																		Memory_flightPlanFinished(true)
																	)\{|get_flightPlanFinished,set_flightPlanFinished|}
																)
																[| {|get_adirection,set_adirection,terminate|} |]
																Memory_adirection(Direction_Up)
															)\{|get_adirection,set_adirection|}
														)
														[| {|get_aWayPoint,set_aWayPoint,terminate|} |]
														Memory_aWayPoint((0,0,0,0))
													)\{|get_aWayPoint,set_aWayPoint|}
												)
												[| {|get_aHomeCoord,set_aHomeCoord,terminate|} |]
												Memory_aHomeCoord((0,0,0,0))
											)\{|get_aHomeCoord,set_aHomeCoord|}
										)
										[| {|get_aAreaSearchPoints,set_aAreaSearchPoints,terminate|} |]
										Memory_aAreaSearchPoints(((0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0)))
									)\{|get_aAreaSearchPoints,set_aAreaSearchPoints|}
								)
								[| {|get_aFlightPlan,set_aFlightPlan,terminate|} |]
								Memory_aFlightPlan(SearchType_AreaSearch)
							)\{|get_aFlightPlan,set_aFlightPlan|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								WaitForInput::enter,
								ExecuteFlightPlan::enter,
								s0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_s0,InputFlightPlan__.NID_WaitForInput.in,InputHomeCoordinate__.NID_WaitForInput.in,ReturnToHome__.NID_WaitForInput.in,FollowFlightPlan__.NID_WaitForInput.in,ManualMovement__.NID_WaitForInput.in,internal__.NID_ExecuteFlightPlan,internal__.NID_ExecuteFlightPlan,internal__.NID_WaitForInput,internal__.NID_ExecuteFlightPlan,internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   WaitForInput::VS_O__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   ExecuteFlightPlan::VS_O__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   [| { share__, terminate } |] (
									   s0::VS_O__(id__,
									   		    const_PilotDisplayStm_hToDCommTime)
									   )
									   )
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[WaitForInput::interrupt <- x__ | x__ <- {|interrupt,InputFlightPlan__.NID_WaitForInput.in,InputHomeCoordinate__.NID_WaitForInput.in,ReturnToHome__.NID_WaitForInput.in,FollowFlightPlan__.NID_WaitForInput.in,ManualMovement__.NID_WaitForInput.in,internal__.NID_WaitForInput|}]]
									 [[ExecuteFlightPlan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_ExecuteFlightPlan,internal__.NID_ExecuteFlightPlan,internal__.NID_ExecuteFlightPlan|}]]
									 [[s0::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_s0|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_adirection,setR_aHomeCoord,setR_aFlightPlan |} ]] 
									  [[set_systemDroneOn <- setL_systemDroneOn,set_flightPlanFinished <- setL_flightPlanFinished,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_systemDroneOn
									 			,setL_flightPlanFinished
									 			,setL_systemHandheld
									 			,setR_adirection
									 			 			,setR_aHomeCoord
									 			 			,setR_aFlightPlan
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PilotDisplayStm_hToDCommTime))
									  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_flightPlanFinished,setL_systemHandheld |} ]]
									  [[set_adirection <- setR_adirection,set_aHomeCoord <- setR_aHomeCoord,set_aFlightPlan <- setR_aFlightPlan]]
									 )
									)[[setL_systemDroneOn <- set_systemDroneOn,setL_flightPlanFinished <- set_flightPlanFinished,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_adirection <- set_adirection,setR_aHomeCoord <- set_aHomeCoord,setR_aFlightPlan <- set_aFlightPlan]]
									)
								)
								 \ hideSet)
								[[
									FollowFlightPlan__.x____ <- FollowFlightPlan,
									InputFlightPlan__.x____ <- InputFlightPlan,
									InputAreaCoordinates__.x____ <- InputAreaCoordinates,
									InputHomeCoordinate__.x____ <- InputHomeCoordinate,
									InputCoordinate__.x____ <- InputCoordinate,
									ManualMovement__.x____ <- ManualMovement,
									StopSearch__.x____ <- StopSearch,
									ReturnToHome__.x____ <- ReturnToHome
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PilotDisplayStm_hToDCommTime)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered,get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_PilotDisplayStm_hToDCommTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PilotDisplayStm_hToDCommTime)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered,get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody_VS_O(id__,
															    const_PilotDisplayStm_hToDCommTime)
													[| {|get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered,terminate|} |]
													dbisim(Clock_CLID_ExecuteFlightPlan(id__,0,
															          const_PilotDisplayStm_hToDCommTime))
												)\{|get_CLID_ExecuteFlightPlan|}
											)
											[| {|get_CLID_s0,s0::entered,terminate|} |]
											dbisim(Clock_CLID_s0(id__,0,
													          const_PilotDisplayStm_hToDCommTime))
										)\{|get_CLID_s0|}
									)
									[| {|get_CLID_WaitForInput,WaitForInput::entered,terminate|} |]
									dbisim(Clock_CLID_WaitForInput(id__,0,
											          const_PilotDisplayStm_hToDCommTime))
								)\{|get_CLID_WaitForInput|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) = 
						dbisim((let
							getsetLocalChannels = {|get_aFlightPlan,set_aFlightPlan,
							get_aAreaSearchPoints,set_aAreaSearchPoints,
							get_aHomeCoord,set_aHomeCoord,
							get_aWayPoint,set_aWayPoint,
							get_adirection,set_adirection,
							get_flightPlanFinished,set_flightPlanFinished|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_PilotDisplayStm_hToDCommTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PilotDisplayStm_hToDCommTime) [| {terminate} |] Clocks(id__,
							 		          const_PilotDisplayStm_hToDCommTime))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		IteratedBehaviour_VS_O(id__,
																				    const_PilotDisplayStm_hToDCommTime)
																		[| {|get_flightPlanFinished,set_flightPlanFinished,terminate|} |]
																		Memory_flightPlanFinished(true)
																	)\{|get_flightPlanFinished,set_flightPlanFinished|}
																)
																[| {|get_adirection,set_adirection,terminate|} |]
																Memory_adirection(Direction_Up)
															)\{|get_adirection,set_adirection|}
														)
														[| {|get_aWayPoint,set_aWayPoint,terminate|} |]
														Memory_aWayPoint((0,0,0,0))
													)\{|get_aWayPoint,set_aWayPoint|}
												)
												[| {|get_aHomeCoord,set_aHomeCoord,terminate|} |]
												Memory_aHomeCoord((0,0,0,0))
											)\{|get_aHomeCoord,set_aHomeCoord|}
										)
										[| {|get_aAreaSearchPoints,set_aAreaSearchPoints,terminate|} |]
										Memory_aAreaSearchPoints(((0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0)))
									)\{|get_aAreaSearchPoints,set_aAreaSearchPoints|}
								)
								[| {|get_aFlightPlan,set_aFlightPlan,terminate|} |]
								Memory_aFlightPlan(SearchType_AreaSearch)
							)\{|get_aFlightPlan,set_aFlightPlan|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_aFlightPlan(aFlightPlan) =
						get_aFlightPlan!aFlightPlan -> Memory_aFlightPlan(aFlightPlan)
						[]
						set_aFlightPlan?x__ -> Memory_aFlightPlan(x__)
						[]
						terminate -> SKIP
					Memory_aAreaSearchPoints(aAreaSearchPoints) =
						get_aAreaSearchPoints!aAreaSearchPoints -> Memory_aAreaSearchPoints(aAreaSearchPoints)
						[]
						set_aAreaSearchPoints?x__ -> Memory_aAreaSearchPoints(x__)
						[]
						terminate -> SKIP
					Memory_aHomeCoord(aHomeCoord) =
						get_aHomeCoord!aHomeCoord -> Memory_aHomeCoord(aHomeCoord)
						[]
						set_aHomeCoord?x__ -> Memory_aHomeCoord(x__)
						[]
						terminate -> SKIP
					Memory_aWayPoint(aWayPoint) =
						get_aWayPoint!aWayPoint -> Memory_aWayPoint(aWayPoint)
						[]
						set_aWayPoint?x__ -> Memory_aWayPoint(x__)
						[]
						terminate -> SKIP
					Memory_adirection(adirection) =
						get_adirection!adirection -> Memory_adirection(adirection)
						[]
						set_adirection?x__ -> Memory_adirection(x__)
						[]
						terminate -> SKIP
					Memory_flightPlanFinished(flightPlanFinished) =
						get_flightPlanFinished!flightPlanFinished -> Memory_flightPlanFinished(flightPlanFinished)
						[]
						set_flightPlanFinished?x__ -> Memory_flightPlanFinished(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_PilotDisplayStm_hToDCommTime) = Memory_aFlightPlan(SearchType_AreaSearch)
					[| { terminate } |] (
					Memory_aAreaSearchPoints(((0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0)))
					[| { terminate } |] (
					Memory_aHomeCoord((0,0,0,0))
					[| { terminate } |] (
					Memory_aWayPoint((0,0,0,0))
					[| { terminate } |] (
					Memory_adirection(Direction_Up)
					[| { terminate } |] (
					Memory_flightPlanFinished(true)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_aFlightPlan,set_aFlightPlan,get_aAreaSearchPoints,set_aAreaSearchPoints,get_aHomeCoord,set_aHomeCoord,get_aWayPoint,set_aWayPoint,get_adirection,set_adirection,get_flightPlanFinished,set_flightPlanFinished|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_PilotDisplayStm_hToDCommTime) = STM_VS_O(id__,
							    const_PilotDisplayStm_hToDCommTime) \ localClockResets
					D__(id__,
							    const_PilotDisplayStm_hToDCommTime) = timed_priority(STM(id__,
							    const_PilotDisplayStm_hToDCommTime) \ union(internal_events,localClockResets))
					O__(id__,
							    const_PilotDisplayStm_hToDCommTime) = dbisim(D__(id__,
							    const_PilotDisplayStm_hToDCommTime))
					VS__(id__,
							    const_PilotDisplayStm_hToDCommTime) = FVS__(id__,
							    const_PilotDisplayStm_hToDCommTime)
					VS_O__(id__,
							    const_PilotDisplayStm_hToDCommTime) = dbisim(FVS__(id__,
							    const_PilotDisplayStm_hToDCommTime))
					HEXT__(id__,
							    const_PilotDisplayStm_hToDCommTime) = O__(id__,
							    const_PilotDisplayStm_hToDCommTime) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_PilotDisplayStm_hToDCommTime) = dbisim(timed_priority(STM(id__,
							    const_PilotDisplayStm_hToDCommTime) \ internal_events))
					HUP__(id__,
							    const_PilotDisplayStm_hToDCommTime) = timed_priority(O__(id__,
							    const_PilotDisplayStm_hToDCommTime) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_PilotDisplayStm_hToDCommTime) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_WaitForInput(id__,x__,
							          const_PilotDisplayStm_hToDCommTime) = 
						TimeOut_1(
							WaitForInput::entered -> Clock_CLID_WaitForInput(id__,0,
									          const_PilotDisplayStm_hToDCommTime)
							[]
							get_CLID_WaitForInput!x__ -> Clock_CLID_WaitForInput(id__,x__,
									          const_PilotDisplayStm_hToDCommTime)
							[]
							terminate -> SKIP,Clock_CLID_WaitForInput(id__,clock_type_plus(x__,1,CLID_WaitForInput_clock_type(id__,
									          const_PilotDisplayStm_hToDCommTime)),
									          const_PilotDisplayStm_hToDCommTime))
					Clock_CLID_s0(id__,x__,
							          const_PilotDisplayStm_hToDCommTime) = 
						TimeOut_1(
							s0::entered -> Clock_CLID_s0(id__,0,
									          const_PilotDisplayStm_hToDCommTime)
							[]
							get_CLID_s0!x__ -> Clock_CLID_s0(id__,x__,
									          const_PilotDisplayStm_hToDCommTime)
							[]
							terminate -> SKIP,Clock_CLID_s0(id__,clock_type_plus(x__,1,CLID_s0_clock_type(id__,
									          const_PilotDisplayStm_hToDCommTime)),
									          const_PilotDisplayStm_hToDCommTime))
					Clock_CLID_ExecuteFlightPlan(id__,x__,
							          const_PilotDisplayStm_hToDCommTime) = 
						TimeOut_1(
							ExecuteFlightPlan::entered -> Clock_CLID_ExecuteFlightPlan(id__,0,
									          const_PilotDisplayStm_hToDCommTime)
							[]
							get_CLID_ExecuteFlightPlan!x__ -> Clock_CLID_ExecuteFlightPlan(id__,x__,
									          const_PilotDisplayStm_hToDCommTime)
							[]
							terminate -> SKIP,Clock_CLID_ExecuteFlightPlan(id__,clock_type_plus(x__,1,CLID_ExecuteFlightPlan_clock_type(id__,
									          const_PilotDisplayStm_hToDCommTime)),
									          const_PilotDisplayStm_hToDCommTime))
					
					StateClocks(id__,
							          const_PilotDisplayStm_hToDCommTime) = dbisim(Clock_CLID_WaitForInput(id__,0,
							          const_PilotDisplayStm_hToDCommTime))
					[| { terminate } |] (
					dbisim(Clock_CLID_s0(id__,0,
							          const_PilotDisplayStm_hToDCommTime))
					[| { terminate } |] (
					dbisim(Clock_CLID_ExecuteFlightPlan(id__,0,
							          const_PilotDisplayStm_hToDCommTime))
					)
					)
					
					stateClockSync = {|get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered,get_CLID_ExecuteFlightPlan,ExecuteFlightPlan::entered|}
					
					-- Shared memory
					-- Shared memory variables
					Memory_systemDroneOn(systemDroneOn) =
						get_systemDroneOn!systemDroneOn -> Memory_systemDroneOn(systemDroneOn)
						[]
						set_systemDroneOn?x__ -> Memory_systemDroneOn(x__)
						[]
						set_EXT_systemDroneOn?x__ -> Memory_systemDroneOn(x__)
						[]
						terminate -> SKIP
					Memory_systemHandheld(systemHandheld) =
						get_systemHandheld!systemHandheld -> Memory_systemHandheld(systemHandheld)
						[]
						set_systemHandheld?x__ -> Memory_systemHandheld(x__)
						[]
						set_EXT_systemHandheld?x__ -> Memory_systemHandheld(x__)
						[]
						terminate -> SKIP
					Memory_FlightPlan(FlightPlan) =
						get_FlightPlan!FlightPlan -> Memory_FlightPlan(FlightPlan)
						[]
						set_FlightPlan?x__ -> Memory_FlightPlan(x__)
						[]
						set_EXT_FlightPlan?x__ -> Memory_FlightPlan(x__)
						[]
						terminate -> SKIP
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_PilotDisplayStm_hToDCommTime) = Memory_systemDroneOn(true)
					[| { terminate } |] (
					Memory_systemHandheld(SystemPower_On)
					[| { terminate } |] (
					Memory_FlightPlan(SearchType_AreaSearch)
					)
					)
					
					sharedVarSync = {|get_systemDroneOn,set_systemDroneOn,set_EXT_systemDroneOn,get_systemHandheld,set_systemHandheld,set_EXT_systemHandheld,get_FlightPlan,set_FlightPlan,set_EXT_FlightPlan|}
					
					sharedVarHide = {|get_systemDroneOn,get_systemHandheld,get_FlightPlan|}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__OnOffDrone(id__) 	= OnOffDroneCall -> SKIP
					CALL__MoveDrone(id__,
							    param_direction) 	= MoveDroneCall.param_direction -> SKIP
					CALL__DroneStopSearch(id__) 	= DroneStopSearchCall -> SKIP
					CALL__FlyToCoordinate(id__,
							    param_coord) 	= FlyToCoordinateCall.param_coord -> SKIP
					CALL__FlyToAreaCoordinates(id__,
							    param_coords) 	= FlyToAreaCoordinatesCall.param_coords -> SKIP
					CALL__FollowPlan(id__,
							    param_searchType) 	= FollowPlanCall.param_searchType -> SKIP
					CALL__stopHandheldOperating(id__,
							    param_forceQuit,
							    param_dronePowerTime) 	= stopHandheldOperatingCall.param_forceQuit.param_dronePowerTime -> SKIP
					
					-- declaring controller memory
					Memory(id__, systemDroneOn, systemHandheld, FlightPlan) = (
					set_EXT_systemDroneOn?x__ -> stm_ref0::set_EXT_systemDroneOn!x__ -> 
					Memory(id__,x__,systemHandheld,FlightPlan)
					 []
					set_EXT_systemHandheld?x__ -> stm_ref0::set_EXT_systemHandheld!x__ -> 
					Memory(id__,systemDroneOn,x__,FlightPlan)
					 []
					set_EXT_FlightPlan?x__ -> stm_ref0::set_EXT_FlightPlan!x__ -> 
					Memory(id__,systemDroneOn,systemHandheld,x__)
					)
					
					D__(id__,
							    const_PilotDisplayController_stm_ref0_hToDCommTime) = prioritise(	((
							let
								const_PilotDisplayStm_hToDCommTime = const_PilotDisplayController_stm_ref0_hToDCommTime
							within 
							stm_ref0::D__(id__,
									    const_PilotDisplayStm_hToDCommTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::FollowFlightPlan <- FollowFlightPlan,
								stm_ref0::InputFlightPlan <- InputFlightPlan,
								stm_ref0::InputAreaCoordinates <- InputAreaCoordinates,
								stm_ref0::InputCoordinate <- InputCoordinate,
								stm_ref0::ManualMovement <- ManualMovement,
								stm_ref0::StopSearch <- StopSearch,
								stm_ref0::ReturnToHome <- ReturnToHome,
								stm_ref0::InputHomeCoordinate <- InputHomeCoordinate,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::set_FlightPlan <- set_FlightPlan,
								stm_ref0::get_FlightPlan <- get_FlightPlan,
								stm_ref0::MoveDroneCall <- MoveDroneCall,
								stm_ref0::DroneStopSearchCall <- DroneStopSearchCall,
								stm_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
								stm_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
								stm_ref0::FollowPlanCall <- FollowPlanCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
									|}
								)
							|]
						Memory(id__, true, SystemPower_On, SearchType_AreaSearch)
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
					
					-- VS version
					VS__(id__,
							    const_PilotDisplayController_stm_ref0_hToDCommTime) = prioritise(	((
							let
								const_PilotDisplayStm_hToDCommTime = const_PilotDisplayController_stm_ref0_hToDCommTime
							within 
							stm_ref0::VS__(id__,
									    const_PilotDisplayStm_hToDCommTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::FollowFlightPlan <- FollowFlightPlan,
								stm_ref0::InputFlightPlan <- InputFlightPlan,
								stm_ref0::InputAreaCoordinates <- InputAreaCoordinates,
								stm_ref0::InputCoordinate <- InputCoordinate,
								stm_ref0::ManualMovement <- ManualMovement,
								stm_ref0::StopSearch <- StopSearch,
								stm_ref0::ReturnToHome <- ReturnToHome,
								stm_ref0::InputHomeCoordinate <- InputHomeCoordinate,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::set_FlightPlan <- set_FlightPlan,
								stm_ref0::get_FlightPlan <- get_FlightPlan,
								stm_ref0::MoveDroneCall <- MoveDroneCall,
								stm_ref0::DroneStopSearchCall <- DroneStopSearchCall,
								stm_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
								stm_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
								stm_ref0::FollowPlanCall <- FollowPlanCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
									|}
								)
							|]
						Memory(id__, true, SystemPower_On, SearchType_AreaSearch)
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_PilotDisplayController_stm_ref0_hToDCommTime) = dbisim(prioritise(	((
							let
								const_PilotDisplayStm_hToDCommTime = const_PilotDisplayController_stm_ref0_hToDCommTime
							within 
							stm_ref0::O__(id__,
									    const_PilotDisplayStm_hToDCommTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::FollowFlightPlan <- FollowFlightPlan,
								stm_ref0::InputFlightPlan <- InputFlightPlan,
								stm_ref0::InputAreaCoordinates <- InputAreaCoordinates,
								stm_ref0::InputCoordinate <- InputCoordinate,
								stm_ref0::ManualMovement <- ManualMovement,
								stm_ref0::StopSearch <- StopSearch,
								stm_ref0::ReturnToHome <- ReturnToHome,
								stm_ref0::InputHomeCoordinate <- InputHomeCoordinate,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::set_FlightPlan <- set_FlightPlan,
								stm_ref0::get_FlightPlan <- get_FlightPlan,
								stm_ref0::MoveDroneCall <- MoveDroneCall,
								stm_ref0::DroneStopSearchCall <- DroneStopSearchCall,
								stm_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
								stm_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
								stm_ref0::FollowPlanCall <- FollowPlanCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On, SearchType_AreaSearch))
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_PilotDisplayController_stm_ref0_hToDCommTime) = dbisim(prioritise(	((
							let
								const_PilotDisplayStm_hToDCommTime = const_PilotDisplayController_stm_ref0_hToDCommTime
							within 
							stm_ref0::VS_O__(id__,
									    const_PilotDisplayStm_hToDCommTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::FollowFlightPlan <- FollowFlightPlan,
								stm_ref0::InputFlightPlan <- InputFlightPlan,
								stm_ref0::InputAreaCoordinates <- InputAreaCoordinates,
								stm_ref0::InputCoordinate <- InputCoordinate,
								stm_ref0::ManualMovement <- ManualMovement,
								stm_ref0::StopSearch <- StopSearch,
								stm_ref0::ReturnToHome <- ReturnToHome,
								stm_ref0::InputHomeCoordinate <- InputHomeCoordinate,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::set_FlightPlan <- set_FlightPlan,
								stm_ref0::get_FlightPlan <- get_FlightPlan,
								stm_ref0::MoveDroneCall <- MoveDroneCall,
								stm_ref0::DroneStopSearchCall <- DroneStopSearchCall,
								stm_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
								stm_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
								stm_ref0::FollowPlanCall <- FollowPlanCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On, SearchType_AreaSearch))
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld,stm_ref0::set_EXT_FlightPlan
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
				
					HEXT(id__,
							    const_PilotDisplayController_stm_ref0_hToDCommTime) = O__(id__,
							    const_PilotDisplayController_stm_ref0_hToDCommTime) [|shared_variable_events|] SKIP			
			}
	
		endmodule
		module ctrl_ref2
			shared_variable_events = {|
				set_EXT_systemDroneOn,
				set_EXT_systemHandheld
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel PowerDrone: InOut
			channel PowerHandheld: InOut
			
			channel set_systemDroneOn: core_boolean
			channel get_systemDroneOn: core_boolean
			channel set_systemHandheld: SystemPower
			channel get_systemHandheld: SystemPower
			
			channel set_EXT_systemDroneOn: core_boolean
			channel set_EXT_systemHandheld: SystemPower
			
			-- declaring call and ret events for undefined operations
			channel OnOffDroneCall
			channel powerDroneAutomaticallyCall
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	PowerDrone,
				PowerHandheld
			,	set_EXT_systemDroneOn, set_systemDroneOn,
				set_EXT_systemHandheld, set_systemHandheld
			,	OnOffDroneCall,
				powerDroneAutomaticallyCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {|get_systemDroneOn,set_systemDroneOn,get_systemHandheld,set_systemHandheld|}
	
			-- defined operations
			-- compileOperationDef
			module OP_stopHandheldOperating
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_f0|
				              NID_j0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel PowerDrone__: NIDS.InOut
				channel PowerDrone: InOut
				channel PowerHandheld__: NIDS.InOut
				channel PowerHandheld: InOut
				
				-- Declaring call and ret events for undefined operations
				channel powerDroneAutomaticallyCall
				
				enterSS = {|
				i0::enter,
				f0::enter,
				j0::enter
				|}
				
				enteredSS = 	{|
				f0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	PowerDrone,
					PowerHandheld
				,	powerDroneAutomaticallyCall
					, share__
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_f0 : core_clock_type 
				--channel increment__
				
				CLID_f0_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
				
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
										param_forceQuit,
										param_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
										param_forceQuit,
										param_dronePowerTime) = D__(id__,
										param_forceQuit,
										param_dronePowerTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
										param_forceQuit,
										param_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_forceQuit,
										param_dronePowerTime) = D__(id__,
										param_forceQuit,
										param_dronePowerTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j0
					module j0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
										param_forceQuit,
										param_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_forceQuit,
										param_dronePowerTime) = D__(id__,
										param_forceQuit,
										param_dronePowerTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__powerDroneAutomatically(id__) = EDeadline(powerDroneAutomaticallyCall,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
								param_forceQuit,
								param_dronePowerTime) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_forceQuit,
								param_dronePowerTime) \ {terminate}
					
					STM_VS_O(id__,
								param_forceQuit,
								param_dronePowerTime) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_forceQuit,
								param_dronePowerTime) \ {terminate}
					
					-- Transitions
					Transitions(id__,
								param_forceQuit,
								param_dronePowerTime) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; j0::enter -> SKIP))))
							 [] dbisim(((param_forceQuit==false))&(internal__!NID_j0 -> SKIP ;  ((SKIP ; f0::enter -> SKIP))))
							 [] dbisim(((param_forceQuit==true))&(internal__!NID_j0 -> SKIP ;  ((true&CALL__powerDroneAutomatically(
							 			id__
							 		);SHARE_WAIT(param_dronePowerTime) ; f0::enter -> SKIP))))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
								param_forceQuit,
								param_dronePowerTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								j0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_j0,internal__.NID_j0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   			param_forceQuit,
									   			param_dronePowerTime)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   			param_forceQuit,
									   			param_dronePowerTime)
									   [| { share__, terminate } |] (
									   j0::D__(id__,
									   			param_forceQuit,
									   			param_dronePowerTime)
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_forceQuit,
									 			param_dronePowerTime))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									PowerDrone__.x____ <- PowerDrone,
									PowerHandheld__.x____ <- PowerHandheld
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
								param_forceQuit,
								param_dronePowerTime) = 
						dbisim((let
							stateClockSync = {||}
						 within
							(MachineBody(id__,
										param_forceQuit,
										param_dronePowerTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					
					Stateful(id__,
								param_forceQuit,
								param_dronePowerTime) = 
						((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour(id__,
										param_forceQuit,
										param_dronePowerTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_forceQuit,
							 			param_dronePowerTime) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
								param_forceQuit,
								param_dronePowerTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								j0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_j0,internal__.NID_j0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   			param_forceQuit,
									   			param_dronePowerTime)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   			param_forceQuit,
									   			param_dronePowerTime)
									   [| { share__, terminate } |] (
									   j0::VS_O__(id__,
									   			param_forceQuit,
									   			param_dronePowerTime)
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_forceQuit,
									 			param_dronePowerTime))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									PowerDrone__.x____ <- PowerDrone,
									PowerHandheld__.x____ <- PowerHandheld
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
								param_forceQuit,
								param_dronePowerTime) = 
						dbisim((let
							stateClockSync = {||}
						 within
							(MachineBody_VS_O(id__,
										param_forceQuit,
										param_dronePowerTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					
					Stateful_VS_O(id__,
								param_forceQuit,
								param_dronePowerTime) = 
						dbisim((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
										param_forceQuit,
										param_dronePowerTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_forceQuit,
							 			param_dronePowerTime) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- END
					
					-- Memory
					-- Memory variables
					
					-- varMemory process
					varMemory(id__,
								param_forceQuit,
								param_dronePowerTime) = terminate -> SKIP
					
					getsetLocalChannels = {||}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
								param_forceQuit,
								param_dronePowerTime) = STM_VS_O(id__,
								param_forceQuit,
								param_dronePowerTime) \ localClockResets
					D__(id__,
								param_forceQuit,
								param_dronePowerTime) = timed_priority(STM(id__,
								param_forceQuit,
								param_dronePowerTime) \ union(internal_events,localClockResets))
					O__(id__,
								param_forceQuit,
								param_dronePowerTime) = dbisim(D__(id__,
								param_forceQuit,
								param_dronePowerTime))
					VS__(id__,
								param_forceQuit,
								param_dronePowerTime) = FVS__(id__,
								param_forceQuit,
								param_dronePowerTime)
					VS_O__(id__,
								param_forceQuit,
								param_dronePowerTime) = dbisim(FVS__(id__,
								param_forceQuit,
								param_dronePowerTime))
					HEXT__(id__,
								param_forceQuit,
								param_dronePowerTime) = O__(id__,
								param_forceQuit,
								param_dronePowerTime) [|shared_variable_events|] SKIP
					FVS_C__(id__,
								param_forceQuit,
								param_dronePowerTime) = dbisim(timed_priority(STM(id__,
								param_forceQuit,
								param_dronePowerTime) \ internal_events))
					HUP__(id__,
								param_forceQuit,
								param_dronePowerTime) = timed_priority(O__(id__,
								param_forceQuit,
								param_dronePowerTime) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
					}
						endmodule
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_f0|
				              NID_Off|
				              NID_HandheldOperating
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_forceQuit, set_forceQuit, setL_forceQuit, setR_forceQuit: core_boolean
				channel get_systemDroneOn, set_systemDroneOn, setL_systemDroneOn, setR_systemDroneOn: core_boolean
				channel get_systemHandheld, set_systemHandheld, setL_systemHandheld, setR_systemHandheld: SystemPower
				
				-- Shared variable channels
				channel set_EXT_systemDroneOn: core_boolean
				channel set_EXT_systemHandheld: SystemPower
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel PowerDrone__: NIDS.InOut
				channel PowerDrone: InOut
				channel PowerHandheld__: NIDS.InOut
				channel PowerHandheld: InOut
				
				-- Declaring call and ret events for undefined operations
				channel OnOffDroneCall
				channel powerDroneAutomaticallyCall
				
				enterSS = {|
				i0::enter,
				f0::enter,
				Off::enter,
				HandheldOperating::enter
				|}
				
				enteredSS = 	{|
				f0::entered,
				Off::entered,
				HandheldOperating::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_systemDroneOn,
					set_EXT_systemHandheld
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_systemDroneOn, set_systemDroneOn,
					set_EXT_systemHandheld, set_systemHandheld
				,	PowerDrone,
					PowerHandheld
				,	OnOffDroneCall,
					powerDroneAutomaticallyCall
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_HandheldOperating : core_clock_type 
				channel get_CLID_f0 : core_clock_type 
				channel get_CLID_Off : core_clock_type 
				--channel increment__
				
				CLID_HandheldOperating_clock_type(id__,
						          const_SystemSW_startTime,
						          const_SystemSW_dronePowerTime) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_f0_clock_type(id__,
						          const_SystemSW_startTime,
						          const_SystemSW_dronePowerTime) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Off_clock_type(id__,
						          const_SystemSW_startTime,
						          const_SystemSW_dronePowerTime) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Off
					module Off
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: HandheldOperating
					module HandheldOperating
					
					enterSS = 
							{|			i0::enter,
								DisplayDroneControls::enter,
								DroneOperating::enter
							|}
					enteredSS = 
							{|			DisplayDroneControls::entered,
								DroneOperating::entered
							|}
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						-- declaring identifiers of transitions
						datatype NIDS = 
						              NID_i0|
						              NID_DisplayDroneControls|
						              NID_DroneOperating
						
						channel internal__ : NIDS
						channel PowerDrone__: NIDS.InOut
						channel PowerHandheld__: NIDS.InOut
						
						channel get_CLID_DroneOperating : core_clock_type 
						channel get_CLID_DisplayDroneControls : core_clock_type 
						--channel increment__
						
						CLID_DroneOperating_clock_type(id__,
								          const_SystemSW_startTime,
								          const_SystemSW_dronePowerTime) = 
							let
								max = (clock_type_max(Union({
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						CLID_DisplayDroneControls_clock_type(id__,
								          const_SystemSW_startTime,
								          const_SystemSW_dronePowerTime) = 
							let
								max = (clock_type_max(Union({
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						
						--	Nodes
						-- declaring all nodes
						
						----------------------------------------------------------------------
						-- Initial: i0
						module i0
						exports
						
							channel enter, interrupt
							
							Timed(OneStep) {
								D__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
										
										Termination = terminate -> SKIP
										
										Active 		= share__choice(interrupt -> SKIP) ; Inactive
									within
										Inactive [| {terminate} |> SKIP)
								
								VS_O__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) = D__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: DisplayDroneControls
						module DisplayDroneControls
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_SystemSW_startTime,
										          const_SystemSW_dronePowerTime) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: DroneOperating
						module DroneOperating
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(true & (share__choice(set_systemDroneOn!true -> SKIP))) ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(true & (share__choice(set_systemDroneOn!true -> SKIP))) ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_SystemSW_startTime,
										          const_SystemSW_dronePowerTime) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SHARE_WAIT(const_SystemSW_startTime);share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP)));share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP)));share__choice(get_forceQuit?forceQuit -> true&CALL__stopHandheldOperating(
										 	  			id__,
										 	  		    const_SystemSW_startTime,
										 	  		    const_SystemSW_dronePowerTime,
										 	  			forceQuit,
										 	  			const_SystemSW_dronePowerTime
										 	  		)) ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		dbisim(
									 			sbisim(
									 				(let
									 					-- IMPLEMENTATION NOTE:
									 					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 					-- modules for defining the semantics of each node.
									 					enterSS = {|
									 					i0::enter,
									 					DisplayDroneControls::enter,
									 					DroneOperating::enter
									 					|}
									 					hideSet = union(enterSS,{|exit,exited,internal__|})
									 				within 
									 					((let
									 						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 						-- because CSPM modules are used for the semantics of Node.
									 						flowevts = union(enterSS,{|exit,exited,interrupt|})
									 						transSync = {|internal__.NID_i0,PowerDrone__.NID_DisplayDroneControls.in,PowerDrone__.NID_DroneOperating.in|}
									 					within
									 						((
									 						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 						   i0::D__(id__,
									 						   		    const_SystemSW_startTime,
									 						   		    const_SystemSW_dronePowerTime)
									 						   [| { share__, terminate } |] (
									 						   DisplayDroneControls::D__(id__,
									 						   		    const_SystemSW_startTime,
									 						   		    const_SystemSW_dronePowerTime)
									 						   [| { share__, terminate } |] (
									 						   DroneOperating::D__(id__,
									 						   		    const_SystemSW_startTime,
									 						   		    const_SystemSW_dronePowerTime)
									 						   )
									 						   )
									 						 )
									 						 [[DisplayDroneControls::interrupt <- x__ | x__ <- {|interrupt,PowerDrone__.NID_DisplayDroneControls.in|}]]
									 						 [[DroneOperating::interrupt <- x__ | x__ <- {|interrupt,PowerDrone__.NID_DroneOperating.in|}]]
									 						 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 						 )
									 						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 						 )
									 						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 						|}) |]
									 						 ((i0::enter -> Transitions(id__,
									 						 		    const_SystemSW_startTime,
									 						 		    const_SystemSW_dronePowerTime))
									 						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 						 )
									 						)
									 						)
									 					)
									 					 \ hideSet)
									 					[[
									 						PowerDrone__.x____ <- PowerDrone,
									 						PowerHandheld__.x____ <- PowerHandheld
									 						| x____ <- NIDS
									 					]]
									 				)
									 				[| {|get_CLID_DisplayDroneControls,DisplayDroneControls::entered,terminate|} |]
									 				dbisim(Clock_CLID_DisplayDroneControls(id__,0,
									 						          const_SystemSW_startTime,
									 						          const_SystemSW_dronePowerTime))
									 			)\{|get_CLID_DisplayDroneControls|}
									 		)
									 		[| {|get_CLID_DroneOperating,DroneOperating::entered,terminate|} |]
									 		dbisim(Clock_CLID_DroneOperating(id__,0,
									 				          const_SystemSW_startTime,
									 				          const_SystemSW_dronePowerTime))
									 	)\{|get_CLID_DroneOperating|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_systemDroneOn,setR_forceQuit,setR_systemHandheld |} ]] 
									  [[set_systemDroneOn <- setL_systemDroneOn,set_forceQuit <- setL_forceQuit,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_systemDroneOn
									 			,setL_forceQuit
									 			,setL_systemHandheld
									 			,setR_systemDroneOn
									 			 			,setR_forceQuit
									 			 			,setR_systemHandheld
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_forceQuit,setL_systemHandheld |} ]]
									  [[set_systemDroneOn <- setR_systemDroneOn,set_forceQuit <- setR_forceQuit,set_systemHandheld <- setR_systemHandheld]]
									 )
									)[[setL_systemDroneOn <- set_systemDroneOn,setL_forceQuit <- set_forceQuit,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_systemDroneOn <- set_systemDroneOn,setR_forceQuit <- set_forceQuit,setR_systemHandheld <- set_systemHandheld]]
									)\union(enteredSS,{terminate}) 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SHARE_WAIT(const_SystemSW_startTime);share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP)));share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP)));share__choice(get_forceQuit?forceQuit -> true&CALL__stopHandheldOperating(
										 	  			id__,
										 	  		    const_SystemSW_startTime,
										 	  		    const_SystemSW_dronePowerTime,
										 	  			forceQuit,
										 	  			const_SystemSW_dronePowerTime
										 	  		)) ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		dbisim(
									 			sbisim(
									 				(let
									 					-- IMPLEMENTATION NOTE:
									 					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 					-- modules for defining the semantics of each node.
									 					enterSS = {|
									 					i0::enter,
									 					DisplayDroneControls::enter,
									 					DroneOperating::enter
									 					|}
									 					hideSet = union(enterSS,{|exit,exited,internal__|})
									 				within 
									 					((let
									 						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 						-- because CSPM modules are used for the semantics of Node.
									 						flowevts = union(enterSS,{|exit,exited,interrupt|})
									 						transSync = {|internal__.NID_i0,PowerDrone__.NID_DisplayDroneControls.in,PowerDrone__.NID_DroneOperating.in|}
									 					within
									 						((
									 						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 						   i0::VS_O__(id__,
									 						   		    const_SystemSW_startTime,
									 						   		    const_SystemSW_dronePowerTime)
									 						   [| { share__, terminate } |] (
									 						   DisplayDroneControls::VS_O__(id__,
									 						   		    const_SystemSW_startTime,
									 						   		    const_SystemSW_dronePowerTime)
									 						   [| { share__, terminate } |] (
									 						   DroneOperating::VS_O__(id__,
									 						   		    const_SystemSW_startTime,
									 						   		    const_SystemSW_dronePowerTime)
									 						   )
									 						   )
									 						 )
									 						 [[DisplayDroneControls::interrupt <- x__ | x__ <- {|interrupt,PowerDrone__.NID_DisplayDroneControls.in|}]]
									 						 [[DroneOperating::interrupt <- x__ | x__ <- {|interrupt,PowerDrone__.NID_DroneOperating.in|}]]
									 						 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 						 )
									 						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 						 )
									 						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 						|}) |]
									 						 ((i0::enter -> Transitions(id__,
									 						 		    const_SystemSW_startTime,
									 						 		    const_SystemSW_dronePowerTime))
									 						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 						 )
									 						)
									 						)
									 					)
									 					 \ hideSet)
									 					[[
									 						PowerDrone__.x____ <- PowerDrone,
									 						PowerHandheld__.x____ <- PowerHandheld
									 						| x____ <- NIDS
									 					]]
									 				)
									 				[| {|get_CLID_DisplayDroneControls,DisplayDroneControls::entered,terminate|} |]
									 				dbisim(Clock_CLID_DisplayDroneControls(id__,0,
									 						          const_SystemSW_startTime,
									 						          const_SystemSW_dronePowerTime))
									 			)\{|get_CLID_DisplayDroneControls|}
									 		)
									 		[| {|get_CLID_DroneOperating,DroneOperating::entered,terminate|} |]
									 		dbisim(Clock_CLID_DroneOperating(id__,0,
									 				          const_SystemSW_startTime,
									 				          const_SystemSW_dronePowerTime))
									 	)\{|get_CLID_DroneOperating|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_systemDroneOn,setR_forceQuit,setR_systemHandheld |} ]] 
									  [[set_systemDroneOn <- setL_systemDroneOn,set_forceQuit <- setL_forceQuit,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_systemDroneOn
									 			,setL_forceQuit
									 			,setL_systemHandheld
									 			,setR_systemDroneOn
									 			 			,setR_forceQuit
									 			 			,setR_systemHandheld
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_forceQuit,setL_systemHandheld |} ]]
									  [[set_systemDroneOn <- setR_systemDroneOn,set_forceQuit <- setR_forceQuit,set_systemHandheld <- setR_systemHandheld]]
									 )
									)[[setL_systemDroneOn <- set_systemDroneOn,setL_forceQuit <- set_forceQuit,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_systemDroneOn <- set_systemDroneOn,setR_forceQuit <- set_forceQuit,setR_systemHandheld <- set_systemHandheld]]
									)\{terminate} 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
							
							Transitions(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) = ((let
								Trans = TimeOut_1(
									 (share__ -> SKIP
									 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; DisplayDroneControls::enter -> SKIP))))
									 [] dbisim((true)&(PowerDrone__!NID_DisplayDroneControls.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__OnOffDrone(
									 			id__,
									 		    const_SystemSW_startTime,
									 		    const_SystemSW_dronePowerTime
									 		);SHARE_WAIT(const_SystemSW_dronePowerTime);share__choice(true & (share__choice(set_forceQuit!true -> SKIP))) ; DroneOperating::enter -> SKIP)))
									 [] dbisim((true)&(PowerDrone__!NID_DroneOperating.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__OnOffDrone(
									 			id__,
									 		    const_SystemSW_startTime,
									 		    const_SystemSW_dronePowerTime
									 		);share__choice(true & (share__choice(set_forceQuit!false -> SKIP)));SHARE_WAIT(const_SystemSW_dronePowerTime) ; DisplayDroneControls::enter -> SKIP)))
									 []
									 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
									 []
									 terminate -> SKIP
									 )
								,SKIP);Trans
							within
								Trans [|{terminate}|> SKIP
							)
							)
							
							
							-- Clocks
							Clock_CLID_DroneOperating(id__,x__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime) = 
								TimeOut_1(
									DroneOperating::entered -> Clock_CLID_DroneOperating(id__,0,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime)
									[]
									get_CLID_DroneOperating!x__ -> Clock_CLID_DroneOperating(id__,x__,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime)
									[]
									terminate -> SKIP,Clock_CLID_DroneOperating(id__,clock_type_plus(x__,1,CLID_DroneOperating_clock_type(id__,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime)),
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime))
							Clock_CLID_DisplayDroneControls(id__,x__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime) = 
								TimeOut_1(
									DisplayDroneControls::entered -> Clock_CLID_DisplayDroneControls(id__,0,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime)
									[]
									get_CLID_DisplayDroneControls!x__ -> Clock_CLID_DisplayDroneControls(id__,x__,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime)
									[]
									terminate -> SKIP,Clock_CLID_DisplayDroneControls(id__,clock_type_plus(x__,1,CLID_DisplayDroneControls_clock_type(id__,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime)),
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime))
							
							StateClocks(id__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime) = dbisim(Clock_CLID_DroneOperating(id__,0,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime))
							[| { terminate } |] (
							dbisim(Clock_CLID_DisplayDroneControls(id__,0,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime))
							)
							
							stateClockSync = {|get_CLID_DroneOperating,DroneOperating::entered,get_CLID_DisplayDroneControls,DisplayDroneControls::entered|}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__OnOffDrone(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = EDeadline(OnOffDroneCall,0)
					CALL__powerDroneAutomatically(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = EDeadline(powerDroneAutomaticallyCall,0)
					
					CALL__stopHandheldOperating(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime,
								param_forceQuit,
								param_dronePowerTime) = (OP_stopHandheldOperating::O__(id__,
								param_forceQuit,
								param_dronePowerTime))
					[[
						OP_stopHandheldOperating::PowerDrone <- PowerDrone,
						OP_stopHandheldOperating::PowerHandheld <- PowerHandheld
					]]
					[[
						OP_stopHandheldOperating::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
					]]
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {|set_EXT_systemDroneOn,set_EXT_systemHandheld|} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SystemSW_startTime,
								    const_SystemSW_dronePowerTime))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {|set_EXT_systemDroneOn,set_EXT_systemHandheld|} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SystemSW_startTime,
								    const_SystemSW_dronePowerTime))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Off::enter -> SKIP))))
							 [] dbisim((true)&(PowerHandheld__!NID_Off.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_systemHandheld!SystemPower_On -> SKIP))) ; HandheldOperating::enter -> SKIP)))
							 [] dbisim((true)&(PowerHandheld__!NID_HandheldOperating.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP))) ; f0::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								Off::enter,
								HandheldOperating::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,PowerHandheld__.NID_Off.in,PowerHandheld__.NID_HandheldOperating.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   [| { share__, terminate } |] (
									   Off::D__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   [| { share__, terminate } |] (
									   HandheldOperating::D__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   )
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[Off::interrupt <- x__ | x__ <- {|interrupt,PowerHandheld__.NID_Off.in|}]]
									 [[HandheldOperating::interrupt <- x__ | x__ <- {|interrupt,PowerHandheld__.NID_HandheldOperating.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SystemSW_startTime,
									 		    const_SystemSW_dronePowerTime))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									PowerDrone__.x____ <- PowerDrone,
									PowerHandheld__.x____ <- PowerHandheld
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SystemSW_startTime,
							 		          const_SystemSW_dronePowerTime)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_HandheldOperating,HandheldOperating::entered,get_CLID_Off,Off::entered|}
						 within
							(MachineBody(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_HandheldOperating,HandheldOperating::entered,get_CLID_Off,Off::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_SystemSW_startTime,
													    const_SystemSW_dronePowerTime)
											[| {|get_CLID_Off,Off::entered,terminate|} |]
											dbisim(Clock_CLID_Off(id__,0,
													          const_SystemSW_startTime,
													          const_SystemSW_dronePowerTime))
										)\{|get_CLID_Off|}
									)
									[| {|get_CLID_HandheldOperating,HandheldOperating::entered,terminate|} |]
									dbisim(Clock_CLID_HandheldOperating(id__,0,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime))
								)\{|get_CLID_HandheldOperating|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						((let
							getsetLocalChannels = {|get_forceQuit,set_forceQuit|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SystemSW_startTime,
							 		    const_SystemSW_dronePowerTime) [| {terminate} |] Clocks(id__,
							 		          const_SystemSW_startTime,
							 		          const_SystemSW_dronePowerTime))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime)
								[| {|get_forceQuit,set_forceQuit,terminate|} |]
								Memory_forceQuit(false)
							)\{|get_forceQuit,set_forceQuit|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								Off::enter,
								HandheldOperating::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,PowerHandheld__.NID_Off.in,PowerHandheld__.NID_HandheldOperating.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   [| { share__, terminate } |] (
									   Off::VS_O__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   [| { share__, terminate } |] (
									   HandheldOperating::VS_O__(id__,
									   		    const_SystemSW_startTime,
									   		    const_SystemSW_dronePowerTime)
									   )
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[Off::interrupt <- x__ | x__ <- {|interrupt,PowerHandheld__.NID_Off.in|}]]
									 [[HandheldOperating::interrupt <- x__ | x__ <- {|interrupt,PowerHandheld__.NID_HandheldOperating.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SystemSW_startTime,
									 		    const_SystemSW_dronePowerTime))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									PowerDrone__.x____ <- PowerDrone,
									PowerHandheld__.x____ <- PowerHandheld
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SystemSW_startTime,
							 		          const_SystemSW_dronePowerTime)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_HandheldOperating,HandheldOperating::entered,get_CLID_Off,Off::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_HandheldOperating,HandheldOperating::entered,get_CLID_Off,Off::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_SystemSW_startTime,
													    const_SystemSW_dronePowerTime)
											[| {|get_CLID_Off,Off::entered,terminate|} |]
											dbisim(Clock_CLID_Off(id__,0,
													          const_SystemSW_startTime,
													          const_SystemSW_dronePowerTime))
										)\{|get_CLID_Off|}
									)
									[| {|get_CLID_HandheldOperating,HandheldOperating::entered,terminate|} |]
									dbisim(Clock_CLID_HandheldOperating(id__,0,
											          const_SystemSW_startTime,
											          const_SystemSW_dronePowerTime))
								)\{|get_CLID_HandheldOperating|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = 
						dbisim((let
							getsetLocalChannels = {|get_forceQuit,set_forceQuit|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SystemSW_startTime,
							 		    const_SystemSW_dronePowerTime) [| {terminate} |] Clocks(id__,
							 		          const_SystemSW_startTime,
							 		          const_SystemSW_dronePowerTime))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__,
										    const_SystemSW_startTime,
										    const_SystemSW_dronePowerTime)
								[| {|get_forceQuit,set_forceQuit,terminate|} |]
								Memory_forceQuit(false)
							)\{|get_forceQuit,set_forceQuit|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_forceQuit(forceQuit) =
						get_forceQuit!forceQuit -> Memory_forceQuit(forceQuit)
						[]
						set_forceQuit?x__ -> Memory_forceQuit(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = Memory_forceQuit(false)
					
					getsetLocalChannels = {|get_forceQuit,set_forceQuit|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = STM_VS_O(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) \ localClockResets
					D__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = timed_priority(STM(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) \ union(internal_events,localClockResets))
					O__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = dbisim(D__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime))
					VS__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = FVS__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime)
					VS_O__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = dbisim(FVS__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime))
					HEXT__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = O__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = dbisim(timed_priority(STM(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) \ internal_events))
					HUP__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = timed_priority(O__(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_SystemSW_startTime,
							          const_SystemSW_dronePowerTime) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_HandheldOperating(id__,x__,
							          const_SystemSW_startTime,
							          const_SystemSW_dronePowerTime) = 
						TimeOut_1(
							HandheldOperating::entered -> Clock_CLID_HandheldOperating(id__,0,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)
							[]
							get_CLID_HandheldOperating!x__ -> Clock_CLID_HandheldOperating(id__,x__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)
							[]
							terminate -> SKIP,Clock_CLID_HandheldOperating(id__,clock_type_plus(x__,1,CLID_HandheldOperating_clock_type(id__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)),
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime))
					Clock_CLID_Off(id__,x__,
							          const_SystemSW_startTime,
							          const_SystemSW_dronePowerTime) = 
						TimeOut_1(
							Off::entered -> Clock_CLID_Off(id__,0,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)
							[]
							get_CLID_Off!x__ -> Clock_CLID_Off(id__,x__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)
							[]
							terminate -> SKIP,Clock_CLID_Off(id__,clock_type_plus(x__,1,CLID_Off_clock_type(id__,
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime)),
									          const_SystemSW_startTime,
									          const_SystemSW_dronePowerTime))
					
					StateClocks(id__,
							          const_SystemSW_startTime,
							          const_SystemSW_dronePowerTime) = dbisim(Clock_CLID_HandheldOperating(id__,0,
							          const_SystemSW_startTime,
							          const_SystemSW_dronePowerTime))
					[| { terminate } |] (
					dbisim(Clock_CLID_Off(id__,0,
							          const_SystemSW_startTime,
							          const_SystemSW_dronePowerTime))
					)
					
					stateClockSync = {|get_CLID_HandheldOperating,HandheldOperating::entered,get_CLID_Off,Off::entered|}
					
					-- Shared memory
					-- Shared memory variables
					Memory_systemDroneOn(systemDroneOn) =
						get_systemDroneOn!systemDroneOn -> Memory_systemDroneOn(systemDroneOn)
						[]
						set_systemDroneOn?x__ -> Memory_systemDroneOn(x__)
						[]
						set_EXT_systemDroneOn?x__ -> Memory_systemDroneOn(x__)
						[]
						terminate -> SKIP
					Memory_systemHandheld(systemHandheld) =
						get_systemHandheld!systemHandheld -> Memory_systemHandheld(systemHandheld)
						[]
						set_systemHandheld?x__ -> Memory_systemHandheld(x__)
						[]
						set_EXT_systemHandheld?x__ -> Memory_systemHandheld(x__)
						[]
						terminate -> SKIP
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_SystemSW_startTime,
							    const_SystemSW_dronePowerTime) = Memory_systemDroneOn(true)
					[| { terminate } |] (
					Memory_systemHandheld(SystemPower_On)
					)
					
					sharedVarSync = {|get_systemDroneOn,set_systemDroneOn,set_EXT_systemDroneOn,get_systemHandheld,set_systemHandheld,set_EXT_systemHandheld|}
					
					sharedVarHide = {|get_systemDroneOn,get_systemHandheld|}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__OnOffDrone(id__) 	= OnOffDroneCall -> SKIP
					CALL__powerDroneAutomatically(id__) 	= powerDroneAutomaticallyCall -> SKIP
					
					-- declaring controller memory
					Memory(id__, systemDroneOn, systemHandheld) = (
					set_EXT_systemDroneOn?x__ -> stm_ref0::set_EXT_systemDroneOn!x__ -> 
					Memory(id__,x__,systemHandheld)
					 []
					set_EXT_systemHandheld?x__ -> stm_ref0::set_EXT_systemHandheld!x__ -> 
					Memory(id__,systemDroneOn,x__)
					)
					
					D__(id__,
							    const_SystemController_stm_ref0_startTime,
							    const_SystemController_stm_ref0_dronePowerTime) = prioritise(	((
							let
								const_SystemSW_startTime = const_SystemController_stm_ref0_startTime
								const_SystemSW_dronePowerTime = const_SystemController_stm_ref0_dronePowerTime
							within 
							stm_ref0::D__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::PowerHandheld <- PowerHandheld,
								stm_ref0::PowerDrone <- PowerDrone,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::OnOffDroneCall <- OnOffDroneCall,
								stm_ref0::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						Memory(id__, true, SystemPower_On)
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
					
					-- VS version
					VS__(id__,
							    const_SystemController_stm_ref0_startTime,
							    const_SystemController_stm_ref0_dronePowerTime) = prioritise(	((
							let
								const_SystemSW_startTime = const_SystemController_stm_ref0_startTime
								const_SystemSW_dronePowerTime = const_SystemController_stm_ref0_dronePowerTime
							within 
							stm_ref0::VS__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::PowerHandheld <- PowerHandheld,
								stm_ref0::PowerDrone <- PowerDrone,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::OnOffDroneCall <- OnOffDroneCall,
								stm_ref0::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						Memory(id__, true, SystemPower_On)
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_SystemController_stm_ref0_startTime,
							    const_SystemController_stm_ref0_dronePowerTime) = dbisim(prioritise(	((
							let
								const_SystemSW_startTime = const_SystemController_stm_ref0_startTime
								const_SystemSW_dronePowerTime = const_SystemController_stm_ref0_dronePowerTime
							within 
							stm_ref0::O__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::PowerHandheld <- PowerHandheld,
								stm_ref0::PowerDrone <- PowerDrone,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::OnOffDroneCall <- OnOffDroneCall,
								stm_ref0::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On))
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_SystemController_stm_ref0_startTime,
							    const_SystemController_stm_ref0_dronePowerTime) = dbisim(prioritise(	((
							let
								const_SystemSW_startTime = const_SystemController_stm_ref0_startTime
								const_SystemSW_dronePowerTime = const_SystemController_stm_ref0_dronePowerTime
							within 
							stm_ref0::VS_O__(id__,
									    const_SystemSW_startTime,
									    const_SystemSW_dronePowerTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::PowerHandheld <- PowerHandheld,
								stm_ref0::PowerDrone <- PowerDrone,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::OnOffDroneCall <- OnOffDroneCall,
								stm_ref0::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On))
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
				
					HEXT(id__,
							    const_SystemController_stm_ref0_startTime,
							    const_SystemController_stm_ref0_dronePowerTime) = O__(id__,
							    const_SystemController_stm_ref0_startTime,
							    const_SystemController_stm_ref0_dronePowerTime) [|shared_variable_events|] SKIP			
			}
	
		endmodule
		module ctrl_ref3
			shared_variable_events = {|
				set_EXT_systemDroneOn,
				set_EXT_systemHandheld
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel GetDroneBatteryStatus: InOut
			channel DisplayStatus: InOut.Status
			
			channel set_systemDroneOn: core_boolean
			channel get_systemDroneOn: core_boolean
			channel set_systemHandheld: SystemPower
			channel get_systemHandheld: SystemPower
			
			channel set_EXT_systemDroneOn: core_boolean
			channel set_EXT_systemHandheld: SystemPower
			
			-- declaring call and ret events for undefined operations
			channel DisplayDroneBatteryStatusCall: Status
			channel GetBatteryStatusCall
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	GetDroneBatteryStatus,
				DisplayStatus
			,	set_EXT_systemDroneOn, set_systemDroneOn,
				set_EXT_systemHandheld, set_systemHandheld
			,	DisplayDroneBatteryStatusCall,
				GetBatteryStatusCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {|get_systemDroneOn,set_systemDroneOn,get_systemHandheld,set_systemHandheld|}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_f0|
				              NID_WaitForInput|
				              NID_s0|
				              NID_WaitForBatteryStatus
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_aStatus, set_aStatus, setL_aStatus, setR_aStatus: Status
				channel get_systemDroneOn, set_systemDroneOn, setL_systemDroneOn, setR_systemDroneOn: core_boolean
				channel get_systemHandheld, set_systemHandheld, setL_systemHandheld, setR_systemHandheld: SystemPower
				
				-- Shared variable channels
				channel set_EXT_systemDroneOn: core_boolean
				channel set_EXT_systemHandheld: SystemPower
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel GetDroneBatteryStatus__: NIDS.InOut
				channel GetDroneBatteryStatus: InOut
				channel DisplayStatus__: NIDS.InOut.Status
				channel DisplayStatus: InOut.Status
				
				-- Declaring call and ret events for undefined operations
				channel DisplayDroneBatteryStatusCall: Status
				channel GetBatteryStatusCall
				
				enterSS = {|
				i0::enter,
				f0::enter,
				WaitForInput::enter,
				s0::enter,
				WaitForBatteryStatus::enter
				|}
				
				enteredSS = 	{|
				f0::entered,
				WaitForInput::entered,
				s0::entered,
				WaitForBatteryStatus::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
					set_EXT_systemDroneOn,
					set_EXT_systemHandheld
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	set_EXT_systemDroneOn, set_systemDroneOn,
					set_EXT_systemHandheld, set_systemHandheld
				,	GetDroneBatteryStatus,
					DisplayStatus
				,	DisplayDroneBatteryStatusCall,
					GetBatteryStatusCall
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_WaitForBatteryStatus : core_clock_type 
				channel get_CLID_WaitForInput : core_clock_type 
				channel get_CLID_f0 : core_clock_type 
				channel get_CLID_s0 : core_clock_type 
				--channel increment__
				
				CLID_WaitForBatteryStatus_clock_type(id__,
						          const_BatteryStatusStm_hToDCommTime,
						          const_BatteryStatusStm_batteryCallWaitTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForInput_clock_type(id__,
						          const_BatteryStatusStm_hToDCommTime,
						          const_BatteryStatusStm_batteryCallWaitTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_f0_clock_type(id__,
						          const_BatteryStatusStm_hToDCommTime,
						          const_BatteryStatusStm_batteryCallWaitTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_s0_clock_type(id__,
						          const_BatteryStatusStm_hToDCommTime,
						          const_BatteryStatusStm_batteryCallWaitTime) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForInput
					module WaitForInput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s0
					module s0
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP)));share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_systemHandheld!SystemPower_Off -> SKIP)));share__choice(true & (share__choice(set_systemDroneOn!false -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForBatteryStatus
					module WaitForBatteryStatus
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__DisplayDroneBatteryStatus(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime,
								param_status) = EDeadline(DisplayDroneBatteryStatusCall.param_status,0)
					CALL__GetBatteryStatus(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = EDeadline(GetBatteryStatusCall,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_BatteryStatusStm_hToDCommTime,
										    const_BatteryStatusStm_batteryCallWaitTime) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {|set_EXT_systemDroneOn,set_EXT_systemHandheld|} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_BatteryStatusStm_hToDCommTime,
								    const_BatteryStatusStm_batteryCallWaitTime))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_BatteryStatusStm_hToDCommTime,
										    const_BatteryStatusStm_batteryCallWaitTime) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {|set_EXT_systemDroneOn,set_EXT_systemHandheld|} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_BatteryStatusStm_hToDCommTime,
								    const_BatteryStatusStm_batteryCallWaitTime))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = ((let
						Trans = share__choice(get_systemDroneOn?systemDroneOn -> get_systemHandheld?systemHandheld -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; s0::enter -> SKIP))))
							 [] dbisim((((systemHandheld==SystemPower_On) and systemDroneOn))&(internal__!NID_s0 -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
							 [] dbisim(((systemHandheld==SystemPower_Off))&(internal__!NID_WaitForInput -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
							 [] dbisim((DisplayStatus__!NID_WaitForBatteryStatus.in?aStatus:{aStatus|aStatus <- Status, systemDroneOn} -> share__choice(set_aStatus!aStatus -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_aStatus?aStatus -> true&CALL__DisplayDroneBatteryStatus(
							 			id__,
							 		    const_BatteryStatusStm_hToDCommTime,
							 		    const_BatteryStatusStm_batteryCallWaitTime,
							 			aStatus
							 		)) ; WaitForInput::enter -> SKIP)))
							 [] dbisim(((systemHandheld==SystemPower_Off))&(internal__!NID_WaitForBatteryStatus -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
							 [] dbisim((systemDroneOn)&(GetDroneBatteryStatus__!NID_WaitForInput.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__GetBatteryStatus(
							 			id__,
							 		    const_BatteryStatusStm_hToDCommTime,
							 		    const_BatteryStatusStm_batteryCallWaitTime
							 		);SHARE_WAIT(const_BatteryStatusStm_hToDCommTime) ; WaitForBatteryStatus::enter -> SKIP)))
							 [] dbisim(((not (systemDroneOn)))&(internal__!NID_WaitForBatteryStatus -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForInput::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								WaitForInput::enter,
								s0::enter,
								WaitForBatteryStatus::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_s0,internal__.NID_WaitForInput,DisplayStatus__.NID_WaitForBatteryStatus.in,internal__.NID_WaitForBatteryStatus,GetDroneBatteryStatus__.NID_WaitForInput.in,internal__.NID_WaitForBatteryStatus|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   f0::D__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   WaitForInput::D__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   s0::D__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   WaitForBatteryStatus::D__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   )
									   )
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[WaitForInput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForInput,GetDroneBatteryStatus__.NID_WaitForInput.in|}]]
									 [[s0::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_s0|}]]
									 [[WaitForBatteryStatus::interrupt <- x__ | x__ <- {|interrupt,DisplayStatus__.NID_WaitForBatteryStatus.in,internal__.NID_WaitForBatteryStatus,internal__.NID_WaitForBatteryStatus|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_aStatus |} ]] 
									  [[set_systemDroneOn <- setL_systemDroneOn,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_systemDroneOn
									 			,setL_systemHandheld
									 			,setR_aStatus
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_BatteryStatusStm_hToDCommTime,
									 		    const_BatteryStatusStm_batteryCallWaitTime))
									  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_systemHandheld |} ]]
									  [[set_aStatus <- setR_aStatus]]
									 )
									)[[setL_systemDroneOn <- set_systemDroneOn,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_aStatus <- set_aStatus]]
									)
								)
								 \ hideSet)
								[[
									GetDroneBatteryStatus__.x____ <- GetDroneBatteryStatus,
									DisplayStatus__.x____ <- DisplayStatus
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_BatteryStatusStm_hToDCommTime,
							 		          const_BatteryStatusStm_batteryCallWaitTime)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered|}
						 within
							(MachineBody(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody(id__,
															    const_BatteryStatusStm_hToDCommTime,
															    const_BatteryStatusStm_batteryCallWaitTime)
													[| {|get_CLID_s0,s0::entered,terminate|} |]
													dbisim(Clock_CLID_s0(id__,0,
															          const_BatteryStatusStm_hToDCommTime,
															          const_BatteryStatusStm_batteryCallWaitTime))
												)\{|get_CLID_s0|}
											)
											[| {|get_CLID_WaitForInput,WaitForInput::entered,terminate|} |]
											dbisim(Clock_CLID_WaitForInput(id__,0,
													          const_BatteryStatusStm_hToDCommTime,
													          const_BatteryStatusStm_batteryCallWaitTime))
										)\{|get_CLID_WaitForInput|}
									)
									[| {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,terminate|} |]
									dbisim(Clock_CLID_WaitForBatteryStatus(id__,0,
											          const_BatteryStatusStm_hToDCommTime,
											          const_BatteryStatusStm_batteryCallWaitTime))
								)\{|get_CLID_WaitForBatteryStatus|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						((let
							getsetLocalChannels = {|get_aStatus,set_aStatus|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_BatteryStatusStm_hToDCommTime,
							 		    const_BatteryStatusStm_batteryCallWaitTime) [| {terminate} |] Clocks(id__,
							 		          const_BatteryStatusStm_hToDCommTime,
							 		          const_BatteryStatusStm_batteryCallWaitTime))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__,
										    const_BatteryStatusStm_hToDCommTime,
										    const_BatteryStatusStm_batteryCallWaitTime)
								[| {|get_aStatus,set_aStatus,terminate|} |]
								Memory_aStatus(Status_High)
							)\{|get_aStatus,set_aStatus|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((
						let
							finalNodesEntered = {|f0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								f0::enter,
								WaitForInput::enter,
								s0::enter,
								WaitForBatteryStatus::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_s0,internal__.NID_WaitForInput,DisplayStatus__.NID_WaitForBatteryStatus.in,internal__.NID_WaitForBatteryStatus,GetDroneBatteryStatus__.NID_WaitForInput.in,internal__.NID_WaitForBatteryStatus|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   f0::VS_O__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   WaitForInput::VS_O__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   s0::VS_O__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   [| { share__, terminate } |] (
									   WaitForBatteryStatus::VS_O__(id__,
									   		    const_BatteryStatusStm_hToDCommTime,
									   		    const_BatteryStatusStm_batteryCallWaitTime)
									   )
									   )
									   )
									   )
									 )
									 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[WaitForInput::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_WaitForInput,GetDroneBatteryStatus__.NID_WaitForInput.in|}]]
									 [[s0::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_s0|}]]
									 [[WaitForBatteryStatus::interrupt <- x__ | x__ <- {|interrupt,DisplayStatus__.NID_WaitForBatteryStatus.in,internal__.NID_WaitForBatteryStatus,internal__.NID_WaitForBatteryStatus|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_aStatus |} ]] 
									  [[set_systemDroneOn <- setL_systemDroneOn,set_systemHandheld <- setL_systemHandheld]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_systemDroneOn
									 			,setL_systemHandheld
									 			,setR_aStatus
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_BatteryStatusStm_hToDCommTime,
									 		    const_BatteryStatusStm_batteryCallWaitTime))
									  [[ share__ <- x__ | x__ <- {| share__,setL_systemDroneOn,setL_systemHandheld |} ]]
									  [[set_aStatus <- setR_aStatus]]
									 )
									)[[setL_systemDroneOn <- set_systemDroneOn,setL_systemHandheld <- set_systemHandheld]]
									 [[setR_aStatus <- set_aStatus]]
									)
								)
								 \ hideSet)
								[[
									GetDroneBatteryStatus__.x____ <- GetDroneBatteryStatus,
									DisplayStatus__.x____ <- DisplayStatus
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_BatteryStatusStm_hToDCommTime,
							 		          const_BatteryStatusStm_batteryCallWaitTime)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((let
							stateClockSync = {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody_VS_O(id__,
															    const_BatteryStatusStm_hToDCommTime,
															    const_BatteryStatusStm_batteryCallWaitTime)
													[| {|get_CLID_s0,s0::entered,terminate|} |]
													dbisim(Clock_CLID_s0(id__,0,
															          const_BatteryStatusStm_hToDCommTime,
															          const_BatteryStatusStm_batteryCallWaitTime))
												)\{|get_CLID_s0|}
											)
											[| {|get_CLID_WaitForInput,WaitForInput::entered,terminate|} |]
											dbisim(Clock_CLID_WaitForInput(id__,0,
													          const_BatteryStatusStm_hToDCommTime,
													          const_BatteryStatusStm_batteryCallWaitTime))
										)\{|get_CLID_WaitForInput|}
									)
									[| {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,terminate|} |]
									dbisim(Clock_CLID_WaitForBatteryStatus(id__,0,
											          const_BatteryStatusStm_hToDCommTime,
											          const_BatteryStatusStm_batteryCallWaitTime))
								)\{|get_CLID_WaitForBatteryStatus|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = 
						dbisim((let
							getsetLocalChannels = {|get_aStatus,set_aStatus|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_BatteryStatusStm_hToDCommTime,
							 		    const_BatteryStatusStm_batteryCallWaitTime) [| {terminate} |] Clocks(id__,
							 		          const_BatteryStatusStm_hToDCommTime,
							 		          const_BatteryStatusStm_batteryCallWaitTime))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__,
										    const_BatteryStatusStm_hToDCommTime,
										    const_BatteryStatusStm_batteryCallWaitTime)
								[| {|get_aStatus,set_aStatus,terminate|} |]
								Memory_aStatus(Status_High)
							)\{|get_aStatus,set_aStatus|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_aStatus(aStatus) =
						get_aStatus!aStatus -> Memory_aStatus(aStatus)
						[]
						set_aStatus?x__ -> Memory_aStatus(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = Memory_aStatus(Status_High)
					
					getsetLocalChannels = {|get_aStatus,set_aStatus|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = STM_VS_O(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) \ localClockResets
					D__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = timed_priority(STM(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) \ union(internal_events,localClockResets))
					O__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = dbisim(D__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime))
					VS__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = FVS__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime)
					VS_O__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = dbisim(FVS__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime))
					HEXT__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = O__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = dbisim(timed_priority(STM(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) \ internal_events))
					HUP__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = timed_priority(O__(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_WaitForBatteryStatus(id__,x__,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime) = 
						TimeOut_1(
							WaitForBatteryStatus::entered -> Clock_CLID_WaitForBatteryStatus(id__,0,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)
							[]
							get_CLID_WaitForBatteryStatus!x__ -> Clock_CLID_WaitForBatteryStatus(id__,x__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)
							[]
							terminate -> SKIP,Clock_CLID_WaitForBatteryStatus(id__,clock_type_plus(x__,1,CLID_WaitForBatteryStatus_clock_type(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)),
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime))
					Clock_CLID_WaitForInput(id__,x__,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime) = 
						TimeOut_1(
							WaitForInput::entered -> Clock_CLID_WaitForInput(id__,0,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)
							[]
							get_CLID_WaitForInput!x__ -> Clock_CLID_WaitForInput(id__,x__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)
							[]
							terminate -> SKIP,Clock_CLID_WaitForInput(id__,clock_type_plus(x__,1,CLID_WaitForInput_clock_type(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)),
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime))
					Clock_CLID_s0(id__,x__,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime) = 
						TimeOut_1(
							s0::entered -> Clock_CLID_s0(id__,0,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)
							[]
							get_CLID_s0!x__ -> Clock_CLID_s0(id__,x__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)
							[]
							terminate -> SKIP,Clock_CLID_s0(id__,clock_type_plus(x__,1,CLID_s0_clock_type(id__,
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime)),
									          const_BatteryStatusStm_hToDCommTime,
									          const_BatteryStatusStm_batteryCallWaitTime))
					
					StateClocks(id__,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime) = dbisim(Clock_CLID_WaitForBatteryStatus(id__,0,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForInput(id__,0,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime))
					[| { terminate } |] (
					dbisim(Clock_CLID_s0(id__,0,
							          const_BatteryStatusStm_hToDCommTime,
							          const_BatteryStatusStm_batteryCallWaitTime))
					)
					)
					
					stateClockSync = {|get_CLID_WaitForBatteryStatus,WaitForBatteryStatus::entered,get_CLID_WaitForInput,WaitForInput::entered,get_CLID_s0,s0::entered|}
					
					-- Shared memory
					-- Shared memory variables
					Memory_systemDroneOn(systemDroneOn) =
						get_systemDroneOn!systemDroneOn -> Memory_systemDroneOn(systemDroneOn)
						[]
						set_systemDroneOn?x__ -> Memory_systemDroneOn(x__)
						[]
						set_EXT_systemDroneOn?x__ -> Memory_systemDroneOn(x__)
						[]
						terminate -> SKIP
					Memory_systemHandheld(systemHandheld) =
						get_systemHandheld!systemHandheld -> Memory_systemHandheld(systemHandheld)
						[]
						set_systemHandheld?x__ -> Memory_systemHandheld(x__)
						[]
						set_EXT_systemHandheld?x__ -> Memory_systemHandheld(x__)
						[]
						terminate -> SKIP
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_BatteryStatusStm_hToDCommTime,
							    const_BatteryStatusStm_batteryCallWaitTime) = Memory_systemDroneOn(true)
					[| { terminate } |] (
					Memory_systemHandheld(SystemPower_On)
					)
					
					sharedVarSync = {|get_systemDroneOn,set_systemDroneOn,set_EXT_systemDroneOn,get_systemHandheld,set_systemHandheld,set_EXT_systemHandheld|}
					
					sharedVarHide = {|get_systemDroneOn,get_systemHandheld|}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__DisplayDroneBatteryStatus(id__,
							    param_status) 	= DisplayDroneBatteryStatusCall.param_status -> SKIP
					CALL__GetBatteryStatus(id__) 	= GetBatteryStatusCall -> SKIP
					
					-- declaring controller memory
					Memory(id__, systemDroneOn, systemHandheld) = (
					set_EXT_systemDroneOn?x__ -> stm_ref0::set_EXT_systemDroneOn!x__ -> 
					Memory(id__,x__,systemHandheld)
					 []
					set_EXT_systemHandheld?x__ -> stm_ref0::set_EXT_systemHandheld!x__ -> 
					Memory(id__,systemDroneOn,x__)
					)
					
					D__(id__,
							    const_BatteryController_stm_ref0_hToDCommTime,
							    const_BatteryController_stm_ref0_batteryCallWaitTime) = prioritise(	((
							let
								const_BatteryStatusStm_hToDCommTime = const_BatteryController_stm_ref0_hToDCommTime
								const_BatteryStatusStm_batteryCallWaitTime = const_BatteryController_stm_ref0_batteryCallWaitTime
							within 
							stm_ref0::D__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::GetDroneBatteryStatus <- GetDroneBatteryStatus,
								stm_ref0::DisplayStatus <- DisplayStatus,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
								stm_ref0::GetBatteryStatusCall <- GetBatteryStatusCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						Memory(id__, true, SystemPower_On)
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
					
					-- VS version
					VS__(id__,
							    const_BatteryController_stm_ref0_hToDCommTime,
							    const_BatteryController_stm_ref0_batteryCallWaitTime) = prioritise(	((
							let
								const_BatteryStatusStm_hToDCommTime = const_BatteryController_stm_ref0_hToDCommTime
								const_BatteryStatusStm_batteryCallWaitTime = const_BatteryController_stm_ref0_batteryCallWaitTime
							within 
							stm_ref0::VS__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::GetDroneBatteryStatus <- GetDroneBatteryStatus,
								stm_ref0::DisplayStatus <- DisplayStatus,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
								stm_ref0::GetBatteryStatusCall <- GetBatteryStatusCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						Memory(id__, true, SystemPower_On)
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_BatteryController_stm_ref0_hToDCommTime,
							    const_BatteryController_stm_ref0_batteryCallWaitTime) = dbisim(prioritise(	((
							let
								const_BatteryStatusStm_hToDCommTime = const_BatteryController_stm_ref0_hToDCommTime
								const_BatteryStatusStm_batteryCallWaitTime = const_BatteryController_stm_ref0_batteryCallWaitTime
							within 
							stm_ref0::O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::GetDroneBatteryStatus <- GetDroneBatteryStatus,
								stm_ref0::DisplayStatus <- DisplayStatus,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
								stm_ref0::GetBatteryStatusCall <- GetBatteryStatusCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On))
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_BatteryController_stm_ref0_hToDCommTime,
							    const_BatteryController_stm_ref0_batteryCallWaitTime) = dbisim(prioritise(	((
							let
								const_BatteryStatusStm_hToDCommTime = const_BatteryController_stm_ref0_hToDCommTime
								const_BatteryStatusStm_batteryCallWaitTime = const_BatteryController_stm_ref0_batteryCallWaitTime
							within 
							stm_ref0::VS_O__(id__,
									    const_BatteryStatusStm_hToDCommTime,
									    const_BatteryStatusStm_batteryCallWaitTime)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::GetDroneBatteryStatus <- GetDroneBatteryStatus,
								stm_ref0::DisplayStatus <- DisplayStatus,
								stm_ref0::set_systemDroneOn <- set_systemDroneOn,
								stm_ref0::get_systemDroneOn <- get_systemDroneOn,
								stm_ref0::set_systemHandheld <- set_systemHandheld,
								stm_ref0::get_systemHandheld <- get_systemHandheld,
								stm_ref0::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
								stm_ref0::GetBatteryStatusCall <- GetBatteryStatusCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
										stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On))
					)
					\ union(
						{|
						|},
						{|
							stm_ref0::set_EXT_systemDroneOn,stm_ref0::set_EXT_systemHandheld
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
				
					HEXT(id__,
							    const_BatteryController_stm_ref0_hToDCommTime,
							    const_BatteryController_stm_ref0_batteryCallWaitTime) = O__(id__,
							    const_BatteryController_stm_ref0_hToDCommTime,
							    const_BatteryController_stm_ref0_batteryCallWaitTime) [|shared_variable_events|] SKIP			
			}
	
		endmodule
	
	Timed(OneStep) {
		visibleMemoryEvents = {|get_systemDroneOn,set_systemDroneOn,get_systemHandheld,set_systemHandheld,get_FlightPlan,set_FlightPlan|}
		
		-- declaring module memory
		Memory(id__, systemDroneOn, systemHandheld, FlightPlan) = (
						set_systemDroneOn?x__ -> 
						ctrl_ref0::set_EXT_systemDroneOn!x__ -> 
						ctrl_ref2::set_EXT_systemDroneOn!x__ -> 
						ctrl_ref3::set_EXT_systemDroneOn!x__ -> 
						Memory(id__,x__,systemHandheld,FlightPlan)
						  []
						set_systemHandheld?x__ -> 
						ctrl_ref0::set_EXT_systemHandheld!x__ -> 
						ctrl_ref2::set_EXT_systemHandheld!x__ -> 
						ctrl_ref3::set_EXT_systemHandheld!x__ -> 
						Memory(id__,systemDroneOn,x__,FlightPlan)
						  []
						set_FlightPlan?x__ -> 
						ctrl_ref0::set_EXT_FlightPlan!x__ -> 
						Memory(id__,systemDroneOn,systemHandheld,x__)
						)
		
		D__(id__,
				    const_PilotDisplayController_stm_ref0_hToDCommTime,
				    const_SystemController_stm_ref0_startTime,
				    const_SystemController_stm_ref0_dronePowerTime,
				    const_BatteryController_stm_ref0_hToDCommTime,
				    const_BatteryController_stm_ref0_batteryCallWaitTime) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							(
								ctrl_ref0::D__(id__,
										    const_PilotDisplayController_stm_ref0_hToDCommTime)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::InputAreaCoordinates <- InputAreaCoordinates,
									ctrl_ref0::FollowFlightPlan <- FollowFlightPlan,
									ctrl_ref0::InputCoordinate <- InputCoordinate,
									ctrl_ref0::ManualMovement <- ManualMovement,
									ctrl_ref0::InputFlightPlan <- InputFlightPlan,
									ctrl_ref0::StopSearch <- StopSearch,
									ctrl_ref0::ReturnToHome <- ReturnToHome,
									ctrl_ref0::InputHomeCoordinate <- InputHomeCoordinate,
									ctrl_ref0::set_systemDroneOn <- set_systemDroneOn,
									ctrl_ref0::get_systemDroneOn <- get_systemDroneOn,
									ctrl_ref0::set_systemHandheld <- set_systemHandheld,
									ctrl_ref0::get_systemHandheld <- get_systemHandheld,
									ctrl_ref0::set_FlightPlan <- set_FlightPlan,
									ctrl_ref0::get_FlightPlan <- get_FlightPlan,
									ctrl_ref0::OnOffDroneCall <- OnOffDroneCall,
									ctrl_ref0::MoveDroneCall <- MoveDroneCall,
									ctrl_ref0::DroneStopSearchCall <- DroneStopSearchCall,
									ctrl_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
									ctrl_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
									ctrl_ref0::FollowPlanCall <- FollowPlanCall,
									ctrl_ref0::stopHandheldOperatingCall <- stopHandheldOperatingCall
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::D__(id__,
											    const_SystemController_stm_ref0_startTime,
											    const_SystemController_stm_ref0_dronePowerTime)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::PowerDrone <- PowerDrone,
										ctrl_ref2::PowerHandheld <- PowerHandheld,
										ctrl_ref2::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref2::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref2::set_systemHandheld <- set_systemHandheld,
										ctrl_ref2::get_systemHandheld <- get_systemHandheld,
										ctrl_ref2::OnOffDroneCall <- OnOffDroneCall,
										ctrl_ref2::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::D__(id__,
											    const_BatteryController_stm_ref0_hToDCommTime,
											    const_BatteryController_stm_ref0_batteryCallWaitTime)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::GetDroneBatteryStatus <- GetDroneBatteryStatus,
										ctrl_ref3::DisplayStatus <- DisplayStatus,
										ctrl_ref3::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref3::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref3::set_systemHandheld <- set_systemHandheld,
										ctrl_ref3::get_systemHandheld <- get_systemHandheld,
										ctrl_ref3::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
										ctrl_ref3::GetBatteryStatusCall <- GetBatteryStatusCall
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
										set_systemDroneOn,
										set_systemHandheld,
										set_FlightPlan
									|},
									{|
										ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
										ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
										ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
									|}
								)
							|]
						Memory(id__, true, SystemPower_On, SearchType_AreaSearch)
					)
				)
				\ Union({
					{|
					|},
					{|
						ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
						ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
						ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
					|},
					{|
						get_systemDroneOn, set_systemDroneOn,
						get_systemHandheld, set_systemHandheld,
						get_FlightPlan, set_FlightPlan
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- visible state equivalent
		
		VS__(id__,
				    const_PilotDisplayController_stm_ref0_hToDCommTime,
				    const_SystemController_stm_ref0_startTime,
				    const_SystemController_stm_ref0_dronePowerTime,
				    const_BatteryController_stm_ref0_hToDCommTime,
				    const_BatteryController_stm_ref0_batteryCallWaitTime) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							(
								ctrl_ref0::VS__(id__,
										    const_PilotDisplayController_stm_ref0_hToDCommTime)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::InputAreaCoordinates <- InputAreaCoordinates,
									ctrl_ref0::FollowFlightPlan <- FollowFlightPlan,
									ctrl_ref0::InputCoordinate <- InputCoordinate,
									ctrl_ref0::ManualMovement <- ManualMovement,
									ctrl_ref0::InputFlightPlan <- InputFlightPlan,
									ctrl_ref0::StopSearch <- StopSearch,
									ctrl_ref0::ReturnToHome <- ReturnToHome,
									ctrl_ref0::InputHomeCoordinate <- InputHomeCoordinate,
									ctrl_ref0::set_systemDroneOn <- set_systemDroneOn,
									ctrl_ref0::get_systemDroneOn <- get_systemDroneOn,
									ctrl_ref0::set_systemHandheld <- set_systemHandheld,
									ctrl_ref0::get_systemHandheld <- get_systemHandheld,
									ctrl_ref0::set_FlightPlan <- set_FlightPlan,
									ctrl_ref0::get_FlightPlan <- get_FlightPlan,
									ctrl_ref0::OnOffDroneCall <- OnOffDroneCall,
									ctrl_ref0::MoveDroneCall <- MoveDroneCall,
									ctrl_ref0::DroneStopSearchCall <- DroneStopSearchCall,
									ctrl_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
									ctrl_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
									ctrl_ref0::FollowPlanCall <- FollowPlanCall,
									ctrl_ref0::stopHandheldOperatingCall <- stopHandheldOperatingCall
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::VS__(id__,
											    const_SystemController_stm_ref0_startTime,
											    const_SystemController_stm_ref0_dronePowerTime)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::PowerDrone <- PowerDrone,
										ctrl_ref2::PowerHandheld <- PowerHandheld,
										ctrl_ref2::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref2::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref2::set_systemHandheld <- set_systemHandheld,
										ctrl_ref2::get_systemHandheld <- get_systemHandheld,
										ctrl_ref2::OnOffDroneCall <- OnOffDroneCall,
										ctrl_ref2::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::VS__(id__,
											    const_BatteryController_stm_ref0_hToDCommTime,
											    const_BatteryController_stm_ref0_batteryCallWaitTime)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::GetDroneBatteryStatus <- GetDroneBatteryStatus,
										ctrl_ref3::DisplayStatus <- DisplayStatus,
										ctrl_ref3::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref3::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref3::set_systemHandheld <- set_systemHandheld,
										ctrl_ref3::get_systemHandheld <- get_systemHandheld,
										ctrl_ref3::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
										ctrl_ref3::GetBatteryStatusCall <- GetBatteryStatusCall
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
										set_systemDroneOn,
										set_systemHandheld,
										set_FlightPlan
									|},
									{|
										ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
										ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
										ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
									|}
								)
							|]
						Memory(id__, true, SystemPower_On, SearchType_AreaSearch)
					)
				)
				\ Union({
					{|
					|},
					{|
						ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
						ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
						ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
					|},
					{|
						get_systemDroneOn, set_systemDroneOn,
						get_systemHandheld, set_systemHandheld,
						get_FlightPlan, set_FlightPlan
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- O version (optimised)
		
		O__(id__,
				    const_PilotDisplayController_stm_ref0_hToDCommTime,
				    const_SystemController_stm_ref0_startTime,
				    const_SystemController_stm_ref0_dronePowerTime,
				    const_BatteryController_stm_ref0_hToDCommTime,
				    const_BatteryController_stm_ref0_batteryCallWaitTime) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							(
								ctrl_ref0::O__(id__,
										    const_PilotDisplayController_stm_ref0_hToDCommTime)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::InputAreaCoordinates <- InputAreaCoordinates,
									ctrl_ref0::FollowFlightPlan <- FollowFlightPlan,
									ctrl_ref0::InputCoordinate <- InputCoordinate,
									ctrl_ref0::ManualMovement <- ManualMovement,
									ctrl_ref0::InputFlightPlan <- InputFlightPlan,
									ctrl_ref0::StopSearch <- StopSearch,
									ctrl_ref0::ReturnToHome <- ReturnToHome,
									ctrl_ref0::InputHomeCoordinate <- InputHomeCoordinate,
									ctrl_ref0::set_systemDroneOn <- set_systemDroneOn,
									ctrl_ref0::get_systemDroneOn <- get_systemDroneOn,
									ctrl_ref0::set_systemHandheld <- set_systemHandheld,
									ctrl_ref0::get_systemHandheld <- get_systemHandheld,
									ctrl_ref0::set_FlightPlan <- set_FlightPlan,
									ctrl_ref0::get_FlightPlan <- get_FlightPlan,
									ctrl_ref0::OnOffDroneCall <- OnOffDroneCall,
									ctrl_ref0::MoveDroneCall <- MoveDroneCall,
									ctrl_ref0::DroneStopSearchCall <- DroneStopSearchCall,
									ctrl_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
									ctrl_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
									ctrl_ref0::FollowPlanCall <- FollowPlanCall,
									ctrl_ref0::stopHandheldOperatingCall <- stopHandheldOperatingCall
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::O__(id__,
											    const_SystemController_stm_ref0_startTime,
											    const_SystemController_stm_ref0_dronePowerTime)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::PowerDrone <- PowerDrone,
										ctrl_ref2::PowerHandheld <- PowerHandheld,
										ctrl_ref2::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref2::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref2::set_systemHandheld <- set_systemHandheld,
										ctrl_ref2::get_systemHandheld <- get_systemHandheld,
										ctrl_ref2::OnOffDroneCall <- OnOffDroneCall,
										ctrl_ref2::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::O__(id__,
											    const_BatteryController_stm_ref0_hToDCommTime,
											    const_BatteryController_stm_ref0_batteryCallWaitTime)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::GetDroneBatteryStatus <- GetDroneBatteryStatus,
										ctrl_ref3::DisplayStatus <- DisplayStatus,
										ctrl_ref3::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref3::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref3::set_systemHandheld <- set_systemHandheld,
										ctrl_ref3::get_systemHandheld <- get_systemHandheld,
										ctrl_ref3::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
										ctrl_ref3::GetBatteryStatusCall <- GetBatteryStatusCall
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
										set_systemDroneOn,
										set_systemHandheld,
										set_FlightPlan
									|},
									{|
										ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
										ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
										ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On, SearchType_AreaSearch))
					)
				)
				\ Union({
					{|
					|},
					{|
						ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
						ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
						ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
					|},
					{|
						get_systemDroneOn, set_systemDroneOn,
						get_systemHandheld, set_systemHandheld,
						get_FlightPlan, set_FlightPlan
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- visible state optimised equivalent
		
		VS_O__(id__,
				    const_PilotDisplayController_stm_ref0_hToDCommTime,
				    const_SystemController_stm_ref0_startTime,
				    const_SystemController_stm_ref0_dronePowerTime,
				    const_BatteryController_stm_ref0_hToDCommTime,
				    const_BatteryController_stm_ref0_batteryCallWaitTime) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							(
								ctrl_ref0::VS_O__(id__,
										    const_PilotDisplayController_stm_ref0_hToDCommTime)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::InputAreaCoordinates <- InputAreaCoordinates,
									ctrl_ref0::FollowFlightPlan <- FollowFlightPlan,
									ctrl_ref0::InputCoordinate <- InputCoordinate,
									ctrl_ref0::ManualMovement <- ManualMovement,
									ctrl_ref0::InputFlightPlan <- InputFlightPlan,
									ctrl_ref0::StopSearch <- StopSearch,
									ctrl_ref0::ReturnToHome <- ReturnToHome,
									ctrl_ref0::InputHomeCoordinate <- InputHomeCoordinate,
									ctrl_ref0::set_systemDroneOn <- set_systemDroneOn,
									ctrl_ref0::get_systemDroneOn <- get_systemDroneOn,
									ctrl_ref0::set_systemHandheld <- set_systemHandheld,
									ctrl_ref0::get_systemHandheld <- get_systemHandheld,
									ctrl_ref0::set_FlightPlan <- set_FlightPlan,
									ctrl_ref0::get_FlightPlan <- get_FlightPlan,
									ctrl_ref0::OnOffDroneCall <- OnOffDroneCall,
									ctrl_ref0::MoveDroneCall <- MoveDroneCall,
									ctrl_ref0::DroneStopSearchCall <- DroneStopSearchCall,
									ctrl_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
									ctrl_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
									ctrl_ref0::FollowPlanCall <- FollowPlanCall,
									ctrl_ref0::stopHandheldOperatingCall <- stopHandheldOperatingCall
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::VS_O__(id__,
											    const_SystemController_stm_ref0_startTime,
											    const_SystemController_stm_ref0_dronePowerTime)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::PowerDrone <- PowerDrone,
										ctrl_ref2::PowerHandheld <- PowerHandheld,
										ctrl_ref2::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref2::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref2::set_systemHandheld <- set_systemHandheld,
										ctrl_ref2::get_systemHandheld <- get_systemHandheld,
										ctrl_ref2::OnOffDroneCall <- OnOffDroneCall,
										ctrl_ref2::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::VS_O__(id__,
											    const_BatteryController_stm_ref0_hToDCommTime,
											    const_BatteryController_stm_ref0_batteryCallWaitTime)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::GetDroneBatteryStatus <- GetDroneBatteryStatus,
										ctrl_ref3::DisplayStatus <- DisplayStatus,
										ctrl_ref3::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref3::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref3::set_systemHandheld <- set_systemHandheld,
										ctrl_ref3::get_systemHandheld <- get_systemHandheld,
										ctrl_ref3::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
										ctrl_ref3::GetBatteryStatusCall <- GetBatteryStatusCall
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
										set_systemDroneOn,
										set_systemHandheld,
										set_FlightPlan
									|},
									{|
										ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
										ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
										ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On, SearchType_AreaSearch))
					)
				)
				\ Union({
					{|
					|},
					{|
						ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
						ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
						ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
					|},
					{|
						get_systemDroneOn, set_systemDroneOn,
						get_systemHandheld, set_systemHandheld,
						get_FlightPlan, set_FlightPlan
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- O version (optimised) with visible assignments
		
		AS_O__(id__,
				    const_PilotDisplayController_stm_ref0_hToDCommTime,
				    const_SystemController_stm_ref0_startTime,
				    const_SystemController_stm_ref0_dronePowerTime,
				    const_BatteryController_stm_ref0_hToDCommTime,
				    const_BatteryController_stm_ref0_batteryCallWaitTime) = dbisim(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							(
								ctrl_ref0::O__(id__,
										    const_PilotDisplayController_stm_ref0_hToDCommTime)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::InputAreaCoordinates <- InputAreaCoordinates,
									ctrl_ref0::FollowFlightPlan <- FollowFlightPlan,
									ctrl_ref0::InputCoordinate <- InputCoordinate,
									ctrl_ref0::ManualMovement <- ManualMovement,
									ctrl_ref0::InputFlightPlan <- InputFlightPlan,
									ctrl_ref0::StopSearch <- StopSearch,
									ctrl_ref0::ReturnToHome <- ReturnToHome,
									ctrl_ref0::InputHomeCoordinate <- InputHomeCoordinate,
									ctrl_ref0::set_systemDroneOn <- set_systemDroneOn,
									ctrl_ref0::get_systemDroneOn <- get_systemDroneOn,
									ctrl_ref0::set_systemHandheld <- set_systemHandheld,
									ctrl_ref0::get_systemHandheld <- get_systemHandheld,
									ctrl_ref0::set_FlightPlan <- set_FlightPlan,
									ctrl_ref0::get_FlightPlan <- get_FlightPlan,
									ctrl_ref0::OnOffDroneCall <- OnOffDroneCall,
									ctrl_ref0::MoveDroneCall <- MoveDroneCall,
									ctrl_ref0::DroneStopSearchCall <- DroneStopSearchCall,
									ctrl_ref0::FlyToCoordinateCall <- FlyToCoordinateCall,
									ctrl_ref0::FlyToAreaCoordinatesCall <- FlyToAreaCoordinatesCall,
									ctrl_ref0::FollowPlanCall <- FollowPlanCall,
									ctrl_ref0::stopHandheldOperatingCall <- stopHandheldOperatingCall
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::O__(id__,
											    const_SystemController_stm_ref0_startTime,
											    const_SystemController_stm_ref0_dronePowerTime)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::PowerDrone <- PowerDrone,
										ctrl_ref2::PowerHandheld <- PowerHandheld,
										ctrl_ref2::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref2::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref2::set_systemHandheld <- set_systemHandheld,
										ctrl_ref2::get_systemHandheld <- get_systemHandheld,
										ctrl_ref2::OnOffDroneCall <- OnOffDroneCall,
										ctrl_ref2::powerDroneAutomaticallyCall <- powerDroneAutomaticallyCall
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::O__(id__,
											    const_BatteryController_stm_ref0_hToDCommTime,
											    const_BatteryController_stm_ref0_batteryCallWaitTime)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::GetDroneBatteryStatus <- GetDroneBatteryStatus,
										ctrl_ref3::DisplayStatus <- DisplayStatus,
										ctrl_ref3::set_systemDroneOn <- set_systemDroneOn,
										ctrl_ref3::get_systemDroneOn <- get_systemDroneOn,
										ctrl_ref3::set_systemHandheld <- set_systemHandheld,
										ctrl_ref3::get_systemHandheld <- get_systemHandheld,
										ctrl_ref3::DisplayDroneBatteryStatusCall <- DisplayDroneBatteryStatusCall,
										ctrl_ref3::GetBatteryStatusCall <- GetBatteryStatusCall
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
										set_systemDroneOn,
										set_systemHandheld,
										set_FlightPlan
									|},
									{|
										ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
										ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
										ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
									|}
								)
							|]
						dbisim(Memory(id__, true, SystemPower_On, SearchType_AreaSearch))
					)
				)
				\ Union({
					{|
					|},
					{|
						ctrl_ref0::set_EXT_systemDroneOn,ctrl_ref0::set_EXT_systemHandheld,ctrl_ref0::set_EXT_FlightPlan,
						ctrl_ref2::set_EXT_systemDroneOn,ctrl_ref2::set_EXT_systemHandheld,
						ctrl_ref3::set_EXT_systemDroneOn,ctrl_ref3::set_EXT_systemHandheld
					|},
					{|
						get_systemDroneOn,
						get_systemHandheld,
						get_FlightPlan
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		)
	}
	
endmodule
